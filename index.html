<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SB PLANETGEN V13 - IMPACT UPDATE (FIXED)</title>
    <style>
        /* --- CORE VISUALS --- */
        :root {
            --c-bg: #050507;
            --c-panel: #141416;
            --c-border: #27272a;
            --c-accent: #3b82f6;
            --c-accent-glow: rgba(59, 130, 246, 0.5);
            --c-text: #e4e4e7;
            --c-text-dim: #a1a1aa;
            
            --f-mono: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
            --f-sans: system-ui, -apple-system, sans-serif;
        }

        * { box-sizing: border-box; outline: none; }

        body {
            background-color: var(--c-bg);
            color: var(--c-text);
            font-family: var(--f-sans);
            margin: 0;
            height: 100vh;
            display: grid;
            grid-template-columns: 1fr 380px;
            overflow: hidden;
        }

        /* --- LEFT: CANVAS AREA --- */
        .stage {
            position: relative;
            background: radial-gradient(circle at 50% 50%, #1a1a20 0%, #000 90%);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            cursor: grab;
        }
        .stage:active { cursor: grabbing; }

        /* THE 3D CANVAS */
        #webgl-canvas {
            width: 100%; height: 100%;
            z-index: 10;
        }

        /* HIDDEN TEXTURE BAKER */
        #texture-baker-container {
            position: absolute; top: -9999px; left: -9999px; visibility: hidden;
        }

        /* --- RIGHT: CONTROL DECK --- */
        .deck {
            background: var(--c-panel);
            border-left: 1px solid var(--c-border);
            padding: 0;
            display: flex; flex-direction: column;
            overflow-y: auto;
            box-shadow: -10px 0 40px rgba(0,0,0,0.5);
            z-index: 20;
        }

        .deck-header {
            padding: 20px;
            border-bottom: 1px solid var(--c-border);
            background: rgba(0,0,0,0.2);
        }

        h1 {
            font-family: var(--f-mono);
            font-size: 1.1rem;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--c-accent);
            text-shadow: 0 0 15px var(--c-accent-glow);
            display: flex; justify-content: space-between;
        }
        .version { font-size: 0.7em; opacity: 0.5; color: white; }

        .seed-row { display: flex; gap: 8px; }

        input[type="text"] {
            background: var(--c-bg); border: 1px solid var(--c-border); color: var(--c-text);
            font-family: var(--f-mono); padding: 12px; border-radius: 6px; flex: 1;
            font-size: 0.9rem; transition: border 0.2s;
        }
        input[type="text"]:focus { border-color: var(--c-accent); }

        .btn-icon {
            width: 44px; background: var(--c-bg); border: 1px solid var(--c-border);
            color: var(--c-text); border-radius: 6px; cursor: pointer; font-size: 1.2rem;
            transition: all 0.2s;
        }
        .btn-icon:hover { background: var(--c-border); color: #fff; }

        .controls { padding: 20px; display: flex; flex-direction: column; gap: 20px; }

        .section-title {
            font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1.5px;
            color: var(--c-text-dim); font-weight: 700; margin-bottom: 12px;
            display: flex; align-items: center; gap: 8px;
        }
        .section-title::after { content: ''; flex: 1; height: 1px; background: var(--c-border); }

        .btn-action {
            width: 100%; padding: 16px;
            background: linear-gradient(135deg, var(--c-accent) 0%, #2563eb 100%);
            border: none; color: white; font-weight: bold; text-transform: uppercase;
            letter-spacing: 1px; border-radius: 8px; cursor: pointer;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
            transition: transform 0.1s;
        }
        .btn-action:active { transform: scale(0.98); }
        .btn-action:disabled { opacity: 0.5; cursor: wait; filter: saturate(0); }

        /* DATA READOUT PANEL */
        .data-panel {
            background: #0f0f11; border: 1px solid var(--c-border);
            border-radius: 6px; padding: 12px; font-family: var(--f-mono); font-size: 0.75rem;
            display: grid; gap: 8px;
        }
        .data-row { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px dashed #27272a; padding-bottom: 4px; }
        .data-row:last-child { border-bottom: none; }
        .data-lbl { color: var(--c-text-dim); }
        .data-val { color: var(--c-text); font-weight: bold; text-align: right;}
        
        .tag { font-size: 0.7em; padding: 2px 4px; border-radius: 3px; margin-left: 5px; opacity: 0.9; display: inline-block; vertical-align: middle; }
        .tag-c { background: #064e3b; color: #6ee7b7; border: 1px solid #059669; }
        .tag-si { background: #312e81; color: #a5b4fc; border: 1px solid #4f46e5; }
        .tag-fe { background: #451a03; color: #fdba74; border: 1px solid #c2410c; }
        .tag-x { background: #4c1d95; color: #e9d5ff; border: 1px solid #8b5cf6; }
        .tag-bio { background: #831843; color: #f9a8d4; border: 1px solid #db2777; }
        .tag-none { background: #27272a; color: #a1a1aa; border: 1px solid #3f3f46; }

        .temp-range { font-size: 0.8em; opacity: 0.7; margin-left: 5px; }
        .t-min { color: #60a5fa; }
        .t-max { color: #f87171; }

        .tag-life { color: #10b981; text-shadow: 0 0 10px rgba(16,185,129,0.3); font-weight: bold; }
        .tag-dead { color: var(--c-text-dim); opacity: 0.5; }

        /* SLIDERS */
        .slider-group { margin-bottom: 12px; }
        .slider-header {
            display: flex; justify-content: space-between; font-size: 0.8rem;
            margin-bottom: 6px; color: var(--c-text-dim);
        }
        input[type="range"] {
            -webkit-appearance: none; width: 100%; height: 6px;
            background: #27272a; border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%;
            background: var(--c-text); cursor: pointer; border: 2px solid var(--c-bg);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .toggle-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 0; font-size: 0.9rem;
        }
        .switch { position: relative; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-switch {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #27272a; border-radius: 24px; transition: .3s;
        }
        .slider-switch:before {
            position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px;
            background-color: #a1a1aa; border-radius: 50%; transition: .3s;
        }
        input:checked + .slider-switch { background-color: var(--c-accent); }
        input:checked + .slider-switch:before { transform: translateX(20px); background-color: white; }

        .dl-group { margin-top: auto; padding: 24px; border-top: 1px solid var(--c-border); }
        .btn-dl {
            width: 100%; padding: 12px; background: transparent; border: 1px solid var(--c-border);
            color: var(--c-text); border-radius: 6px; cursor: pointer; font-family: var(--f-mono);
            font-size: 0.8rem; display: flex; align-items: center; justify-content: center; gap: 10px;
        }
        .btn-dl:hover { background: #27272a; }

        /* --- RESPONSIVE LAYOUT --- */
        @media (max-width: 800px) {
            body {
                grid-template-columns: 1fr;
                grid-template-rows: minmax(0, 1fr) auto;
                height: 100vh;
                overflow: hidden;
            }

            .deck {
                border-left: none;
                border-top: 1px solid var(--c-border);
                box-shadow: 0 -10px 40px rgba(0,0,0,0.5);
                max-height: 45vh;
                overflow-y: auto;
            }

            .dl-group { margin-top: 12px; padding: 12px; }
        }

    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.4",
    "react-dom/": "https://esm.sh/react-dom@^19.2.4/",
    "react/": "https://esm.sh/react@^19.2.4/"
  }
}
</script>
</head>
<body>

    <div class="stage" id="stage">
        <canvas id="webgl-canvas"></canvas>
    </div>

    <div id="texture-baker-container">
        <!-- SURFACE BAKER (Color) -->
        <svg id="surface-baker" width="2048" height="1024" viewBox="0 0 2048 1024" xmlns="http://www.w3.org/2000/svg">
            <defs id="defs-surface">
                <filter id="geo-blur"><feGaussianBlur stdDeviation="25" /></filter>
                <filter id="liquid-blur"><feGaussianBlur stdDeviation="1" /></filter>
                <filter id="zone-warp">
                     <feTurbulence type="fractalNoise" baseFrequency="0.015" numOctaves="4" seed="123" result="turb"/>
                     <feDisplacementMap in="SourceGraphic" in2="turb" scale="60" xChannelSelector="R" yChannelSelector="G"/>
                     <feGaussianBlur stdDeviation="10" />
                </filter>
            </defs>
            <rect id="bake-bg" width="2048" height="1024" fill="#000" />
            <g id="bake-group-terrain"></g>
            <g id="bake-group-liquid"></g>
            <g id="bake-group-ice"></g>
            <g id="bake-group-bio"></g>
            <g id="bake-group-crater-overlays"></g> <!-- OVERLAY FOR DEPTH -->
        </svg>
        
        <!-- HEIGHT BAKER (Displacement) - Needs its own defs for blob isolation -->
        <svg id="height-baker" width="2048" height="1024" viewBox="0 0 2048 1024" xmlns="http://www.w3.org/2000/svg">
            <defs id="defs-height">
                <!-- Duplicated Filters for Height Map Isolation -->
                <filter id="zone-warp-h">
                     <feTurbulence type="fractalNoise" baseFrequency="0.015" numOctaves="4" seed="123" result="turb"/>
                     <feDisplacementMap in="SourceGraphic" in2="turb" scale="60" xChannelSelector="R" yChannelSelector="G"/>
                     <feGaussianBlur stdDeviation="10" />
                </filter>
            </defs>
            <rect width="2048" height="1024" fill="#000" />
            <g id="bake-group-height"></g>
        </svg>
    </div>

    <div class="deck">
        <div class="deck-header">
            <h1>SB PLANETGEN <span class="version">V14 CRATER</span></h1>
            <div class="seed-row">
                <input type="text" id="seed-input" value="LUNA-CRATER">
                <button class="btn-icon" id="btn-rnd" title="Randomize">ðŸŽ²</button>
            </div>
        </div>

        <div class="controls">
            
            <div class="data-panel" id="data-panel">
                <div class="data-row"><span class="data-lbl">Temperature:</span> <span class="data-val" id="val-temp">--</span></div>
                <div class="data-row"><span class="data-lbl">Surface:</span> <span class="data-val" id="val-solid">--</span></div>
                <div class="data-row"><span class="data-lbl">Fluid:</span> <span class="data-val" id="val-liquid">--</span></div>
                <div class="data-row"><span class="data-lbl">Atmosphere:</span> <span class="data-val" id="val-atmos">--</span></div>
                <div class="data-row"><span class="data-lbl">Biology:</span> <span class="data-val tag-dead" id="val-life">NONE DETECTED</span></div>
            </div>

            <div>
                <div class="section-title">Manual Override</div>
                
                <div class="slider-group">
                    <div class="slider-header">
                        <span>Sea Level</span>
                        <span id="lbl-water">50%</span>
                    </div>
                    <input type="range" id="rng-water" min="0" max="100" value="50">
                </div>

                <div class="toggle-row">
                    <span>Auto Rotate</span>
                    <label class="switch">
                        <input type="checkbox" id="chk-auto-rotate" checked>
                        <span class="slider-switch"></span>
                    </label>
                </div>

                <div class="toggle-row">
                    <span>Show Clouds</span>
                    <label class="switch">
                        <input type="checkbox" id="chk-clouds" checked>
                        <span class="slider-switch"></span>
                    </label>
                </div>
            </div>

            <div>
                <div class="section-title">Lighting</div>
                <div class="slider-group">
                    <div class="slider-header">
                        <span>Sun Angle / Shadow</span>
                        <span id="lbl-shadow">50%</span>
                    </div>
                    <input type="range" id="rng-shadow" min="0" max="100" value="50">
                </div>
            </div>
            
            <button class="btn-action" id="btn-gen">Re-Generate</button>

        </div>

        <div class="dl-group">
            <button class="btn-dl" id="btn-download">
                <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg>
                Download Texture Map
            </button>
        </div>
    </div>

<script type="module">
import * as THREE from 'https://esm.sh/three';

/**
 * SB PLANETGEN V14 - COMPLEX CRATERS UPDATE
 * Amorphous crater shapes with procedural filtering
 */

/* --- DATA CONSTANTS --- */
const CRATER_RIDGE_INTENSITY = 0.1; 
const LIQUIDS = [
    { name: "Water",           color: "#3b82f6", freeze: 0,    boil: 100,  tag: "H2O", cloud: "#ffffff", frozenColor: "#bfdbfe", type: "standard", gas: "Oxygen" },
    { name: "Salt Water",      color: "#1d4ed8", freeze: -2,   boil: 102,  tag: "H2O", cloud: "#f1f5f9", frozenColor: "#a5b4fc", type: "standard", gas: "Oxygen" },
    { name: "Mineral Water",   color: "#22d3ee", freeze: 0,    boil: 100,  tag: "H2O", cloud: "#ecfeff", frozenColor: "#cffafe", type: "standard", gas: "Oxygen" },
    { name: "Heavy Water",     color: "#60a5fa", freeze: 3.8,  boil: 101,  tag: "D2O", cloud: "#e0f2fe", frozenColor: "#93c5fd", type: "standard", gas: "Deuterium" },
    { name: "Brine",           color: "#0891b2", freeze: -21,  boil: 108,  tag: "H2O", cloud: "#f0f9ff", frozenColor: "#bae6fd", type: "standard", gas: "Chlorine" },
    { name: "Swamp Water",     color: "#3f6212", freeze: -1,   boil: 100,  tag: "Bio", cloud: "#d9f99d", frozenColor: "#65a30d", type: "organic",  gas: "Methane" },
    { name: "Mud Water",       color: "#78350f", freeze: 0,    boil: 100,  tag: "Si",  cloud: "#d6d3d1", frozenColor: "#57534e", type: "viscous",  gas: "Oxygen" },
    { name: "Oxygen",          color: "#93c5fd", freeze: -218, boil: -183, tag: "O",   cloud: "#e0f2fe", frozenColor: "#3b82f6", type: "volatile", gas: "Oxygen" },
    { name: "Nitrogen",        color: "#818cf8", freeze: -210, boil: -195, tag: "N",   cloud: "#f1f5f9", frozenColor: "#6366f1", type: "volatile", gas: "Nitrogen" },
    { name: "Hydrogen",        color: "#f0abfc", freeze: -259, boil: -252, tag: "H",   cloud: "#ffffff", frozenColor: "#e879f9", type: "volatile", gas: "Hydrogen" },
    { name: "Helium",          color: "#d8b4fe", freeze: -272, boil: -268, tag: "He",  cloud: "#ffffff", frozenColor: "#c084fc", type: "volatile", gas: "Helium" },
    { name: "Argon",           color: "#c084fc", freeze: -189, boil: -185, tag: "Ar",  cloud: "#e9d5ff", frozenColor: "#a855f7", type: "volatile", gas: "Argon" },
    { name: "Methane",         color: "#06b6d4", freeze: -182, boil: -161, tag: "C",   cloud: "#bae6fd", frozenColor: "#bae6fd", type: "volatile", gas: "Methane" },
    { name: "Propane",         color: "#67e8f9", freeze: -187, boil: -42,  tag: "C",   cloud: "#e0f2fe", frozenColor: "#22d3ee", type: "volatile", gas: "Propane" },
    { name: "Ethanol",         color: "#f1f5f9", freeze: -114, boil: 78,   tag: "C",   cloud: "#f8fafc", frozenColor: "#cbd5e1", type: "volatile", gas: "Carbon Monoxide" },
    { name: "Acetone",         color: "#e2e8f0", freeze: -95,  boil: 56,   tag: "C",   cloud: "#f8fafc", frozenColor: "#94a3b8", type: "volatile", gas: "Carbon Monoxide" },
    { name: "Gasoline",        color: "#facc15", freeze: -60,  boil: 200,  tag: "C",   cloud: "#fef08a", frozenColor: "#eab308", type: "standard", gas: "Carbon Dioxide" },
    { name: "Diesel",          color: "#d97706", freeze: -10,  boil: 300,  tag: "C",   cloud: "#78350f", frozenColor: "#92400e", type: "viscous",  gas: "Carbon Dioxide" },
    { name: "Kerosene",        color: "#fbbf24", freeze: -40,  boil: 250,  tag: "C",   cloud: "#fef3c7", frozenColor: "#f59e0b", type: "standard", gas: "Carbon Dioxide" },
    { name: "Napalm",          color: "#ea580c", freeze: -30,  boil: 200,  tag: "C",   cloud: "#9a3412", frozenColor: "#7c2d12", type: "viscous",  gas: "Carbon Dioxide" },
    { name: "Crude Oil",       color: "#0f172a", freeze: -57,  boil: 200,  tag: "C",   cloud: "#52525b", frozenColor: "#020617", type: "viscous",  gas: "Carbon Monoxide" },
    { name: "Tar",             color: "#171717", freeze: -10,  boil: 300,  tag: "C",   cloud: "#404040", frozenColor: "#0a0a0a", type: "viscous",  gas: "Carbon Dioxide" },
    { name: "Acid",            color: "#65a30d", freeze: 10,   boil: 337,  tag: "S",   cloud: "#d9f99d", frozenColor: "#365314", type: "acid",     gas: "Sulfur" },
    { name: "Vinegar",         color: "#fef08a", freeze: -2,   boil: 118,  tag: "C",   cloud: "#fef9c3", frozenColor: "#facc15", type: "acid",     gas: "Carbon Monoxide" },
    { name: "Ammonia",         color: "#2dd4bf", freeze: -77,  boil: -33,  tag: "N",   cloud: "#99f6e4", frozenColor: "#0d9488", type: "acid",     gas: "Nitrogen" },
    { name: "Chlorine",        color: "#84cc16", freeze: -101, boil: -34,  tag: "Cl",  cloud: "#bef264", frozenColor: "#4d7c0f", type: "acid",     gas: "Chlorine" },
    { name: "Bleach",          color: "#e0f2fe", freeze: -6,   boil: 101,  tag: "Cl",  cloud: "#f0f9ff", frozenColor: "#bae6fd", type: "standard", gas: "Chlorine" },
    { name: "Peroxide",        color: "#cbd5e1", freeze: -0.4, boil: 150,  tag: "O",   cloud: "#e0f2fe", frozenColor: "#64748b", type: "standard", gas: "Oxygen" },
    { name: "Cyanide",         color: "#cffafe", freeze: -13,  boil: 26,   tag: "C",   cloud: "#ecfeff", frozenColor: "#22d3ee", type: "acid",     gas: "Nitrogen" },
    { name: "Formaldehyde",    color: "#f0f9ff", freeze: -92,  boil: -19,  tag: "C",   cloud: "#e0f2fe", frozenColor: "#bae6fd", type: "acid",     gas: "Carbon Monoxide" },
    { name: "Bromine",         color: "#991b1b", freeze: -7,   boil: 58,   tag: "Br",  cloud: "#7f1d1d", frozenColor: "#450a0a", type: "standard", gas: "Bromine" },
    { name: "Mercury",         color: "#94a3b8", freeze: -39,  boil: 357,  tag: "Hg",  cloud: "#e2e8f0", frozenColor: "#475569", type: "metal",    gas: "Mercury" },
    { name: "Gallium",         color: "#cbd5e1", freeze: 29,   boil: 2400, tag: "Ga",  cloud: "#f1f5f9", frozenColor: "#64748b", type: "metal",    gas: "Gallium" },
    { name: "Blood",           color: "#991b1b", freeze: -2,   boil: 100,  tag: "Bio", cloud: "#fca5a5", frozenColor: "#7f1d1d", type: "organic",  gas: "Steam" },
    { name: "Plasma",          color: "#fde68a", freeze: -1,   boil: 100,  tag: "Bio", cloud: "#fef3c7", frozenColor: "#d97706", type: "organic",  gas: "Steam" },
    { name: "Venom",           color: "#a21caf", freeze: -5,   boil: 120,  tag: "Bio", cloud: "#e879f9", frozenColor: "#701a75", type: "acid",     gas: "Unknown" },
    { name: "Honey",           color: "#ea580c", freeze: -20,  boil: 120,  tag: "Bio", cloud: "#fde68a", frozenColor: "#9a3412", type: "viscous",  gas: "Carbon Dioxide" },
    { name: "Lava",            color: "#ef4444", freeze: 700,  boil: 3000, tag: "Si",  cloud: "#57534e", frozenColor: "#292524", type: "magma",    gas: "Silicate" },
    { name: "Magma",           color: "#c2410c", freeze: 800,  boil: 3200, tag: "Si",  cloud: "#44403c", frozenColor: "#1c1917", type: "magma",    gas: "Silicate" },
    { name: "Gold",            color: "#fbbf24", freeze: 1064, boil: 2700, tag: "Au",  cloud: "#fffbeb", frozenColor: "#b45309", type: "metal",    gas: "Vaporized Gold" },
    { name: "Iron",            color: "#f97316", freeze: 1538, boil: 2862, tag: "Fe",  cloud: "#ffedd5", frozenColor: "#c2410c", type: "metal",    gas: "Vaporized Iron" },
    { name: "Copper",          color: "#f87171", freeze: 1085, boil: 2562, tag: "Cu",  cloud: "#fecaca", frozenColor: "#991b1b", type: "metal",    gas: "Vaporized Copper" },
    { name: "Lead",            color: "#9ca3af", freeze: 327,  boil: 1749, tag: "Pb",  cloud: "#e5e7eb", frozenColor: "#4b5563", type: "metal",    gas: "Vaporized Lead" },
    { name: "Chocolate",       color: "#451a03", freeze: 25,   boil: 150,  tag: "Bio", cloud: "#d6d3d1", frozenColor: "#290e02", type: "viscous",  gas: "Carbon Dioxide" },
];

const SOLIDS = [
    { name: "Stone",           color: "#78716c", tag: "Si", roughness: 1.0, type: "rock", melt: 1200 },
    { name: "Basalt",          color: "#27272a", tag: "Si", roughness: 1.0, type: "rock", melt: 1100 },
    { name: "Granite",         color: "#a8a29e", tag: "Si", roughness: 1.3, type: "rock", melt: 1215 },
    { name: "Bedrock",         color: "#1c1917", tag: "Si", roughness: 2.0, type: "rock", melt: 4000 },
    { name: "Sandstone",       color: "#d97706", tag: "Si", roughness: 0.5, type: "rock", melt: 1300 },
    { name: "Limestone",       color: "#e7e5e4", tag: "C",  roughness: 0.8, type: "rock", melt: 900 },
    { name: "Slate",           color: "#475569", tag: "Si", roughness: 0.9, type: "rock", melt: 1200 },
    { name: "Marble",          color: "#cbd5e1", tag: "C",  roughness: 0.7, type: "rock", melt: 1200 },
    { name: "Pumice",          color: "#9ca3af", tag: "Si", roughness: 1.5, type: "rock", melt: 1000 },
    { name: "Obsidian",        color: "#2e1065", tag: "Si", roughness: 1.1, type: "glass",melt: 1000 },
    { name: "Flint",           color: "#374151", tag: "Si", roughness: 0.9, type: "rock", melt: 1700 },
    { name: "Coal",            color: "#0f172a", tag: "C",  roughness: 0.8, type: "rock", melt: 3500 },
    { name: "Chalk",           color: "#e5e7eb", tag: "C",  roughness: 0.6, type: "rock", melt: 825 },
    { name: "Shale",           color: "#334155", tag: "Si", roughness: 0.7, type: "rock", melt: 1100 },
    { name: "Dirt",            color: "#573c29", tag: "Si", roughness: 1.0, type: "dust", melt: 1100 },
    { name: "Mud",             color: "#451a03", tag: "Si", roughness: 0.9, type: "dust", melt: 1100 },
    { name: "Clay",            color: "#9a3412", tag: "Si", roughness: 0.6, type: "dust", melt: 1000 },
    { name: "Sand",            color: "#fde047", tag: "Si", roughness: 1.2, type: "dust", melt: 1700 },
    { name: "Red Sand",        color: "#ea580c", tag: "Si", roughness: 1.2, type: "dust", melt: 1600 },
    { name: "Black Sand",      color: "#18181b", tag: "Si", roughness: 1.1, type: "dust", melt: 1200 },
    { name: "Gravel",          color: "#9ca3af", tag: "Si", roughness: 1.5, type: "rock", melt: 1200 },
    { name: "Ash",             color: "#d6d3d1", tag: "C",  roughness: 1.4, type: "dust", melt: 1000 },
    { name: "Soot",            color: "#171717", tag: "C",  roughness: 1.2, type: "dust", melt: 3000 },
    { name: "Salt",            color: "#e5e7eb", tag: "Na", roughness: 0.8, type: "dust", melt: 801 },
    { name: "Iron Ore",        color: "#7f1d1d", tag: "Fe", roughness: 1.2, type: "metal", melt: 1538 },
    { name: "Magnetite",       color: "#1e293b", tag: "Fe", roughness: 1.1, type: "metal", melt: 1590 },
    { name: "Rust",            color: "#b45309", tag: "Fe", roughness: 1.5, type: "metal", melt: 1500 },
    { name: "Gold",            color: "#facc15", tag: "Au", roughness: 1.0, type: "metal", melt: 1064 },
    { name: "Pyrite",          color: "#ca8a04", tag: "Fe", roughness: 1.3, type: "rock",  melt: 1100 },
    { name: "Silver",          color: "#cbd5e1", tag: "Ag", roughness: 0.8, type: "metal", melt: 961 },
    { name: "Copper",          color: "#f97316", tag: "Cu", roughness: 0.9, type: "metal", melt: 1085 },
    { name: "Bronze",          color: "#cd7f32", tag: "Cu", roughness: 0.9, type: "metal", melt: 950 },
    { name: "Steel",           color: "#64748b", tag: "Fe", roughness: 0.8, type: "metal", melt: 1370 },
    { name: "Lead",            color: "#475569", tag: "Pb", roughness: 0.6, type: "metal", melt: 327 },
    { name: "Tin",             color: "#94a3b8", tag: "Sn", roughness: 0.7, type: "metal", melt: 231 },
    { name: "Aluminum",        color: "#d1d5db", tag: "Al", roughness: 0.6, type: "metal", melt: 660 },
    { name: "Titanium",        color: "#334155", tag: "Ti", roughness: 0.9, type: "metal", melt: 1668 },
    { name: "Tungsten",        color: "#1f2937", tag: "W",  roughness: 1.0, type: "metal", melt: 3422 },
    { name: "Cobalt",          color: "#1e3a8a", tag: "Co", roughness: 1.1, type: "metal", melt: 1495 },
    { name: "Uranium",         color: "#166534", tag: "U",  roughness: 1.0, type: "metal", melt: 1132 },
    { name: "Quartz",          color: "#e2e8f0", tag: "Si", roughness: 1.1, type: "glass", melt: 1670 },
    { name: "Diamond",         color: "#cffafe", tag: "C",  roughness: 1.5, type: "glass", melt: 4000 },
    { name: "Ruby",            color: "#dc2626", tag: "Al", roughness: 1.2, type: "glass", melt: 2050 },
    { name: "Sapphire",        color: "#2563eb", tag: "Al", roughness: 1.2, type: "glass", melt: 2040 },
    { name: "Emerald",         color: "#10b981", tag: "Si", roughness: 1.1, type: "glass", melt: 1200 },
    { name: "Amethyst",        color: "#a855f7", tag: "Si", roughness: 1.3, type: "glass", melt: 1650 },
    { name: "Topaz",           color: "#fb923c", tag: "Si", roughness: 1.1, type: "glass", melt: 1600 },
    { name: "Opal",            color: "#fda4af", tag: "Si", roughness: 0.9, type: "glass", melt: 1000 },
    { name: "Malachite",       color: "#064e3b", tag: "Cu", roughness: 1.0, type: "rock",  melt: 1100 },
    { name: "Sulfur",          color: "#fde047", tag: "S",  roughness: 0.8, type: "rock",  melt: 115 },
    { name: "Ice",             color: "#bae6fd", tag: "H2O",roughness: 0.7, type: "ice",   melt: 0 },
    { name: "Blue Ice",        color: "#60a5fa", tag: "H2O",roughness: 0.9, type: "ice",   melt: 0 },
    { name: "Permafrost",      color: "#9ca3af", tag: "Si", roughness: 1.1, type: "ice",   melt: 0 },
    { name: "Nitrogen Ice",    color: "#c7d2fe", tag: "N",  roughness: 0.5, type: "ice",   melt: -210 },
    { name: "Methane Ice",     color: "#38bdf8", tag: "C",  roughness: 0.5, type: "ice",   melt: -182 },
    { name: "Grass",           color: "#4ade80", tag: "Bio", roughness: 0.5, type: "organic", melt: 100 },
    { name: "Moss",            color: "#3f6212", tag: "Bio", roughness: 1.2, type: "organic", melt: 100 },
    { name: "Bone",            color: "#e5e5e5", tag: "Bio", roughness: 0.9, type: "organic", melt: 200 },
    { name: "Flesh",           color: "#fb7185", tag: "Bio", roughness: 0.5, type: "organic", melt: 100 },
    { name: "Chitin",          color: "#92400e", tag: "Bio", roughness: 0.7, type: "organic", melt: 260 },
    { name: "Mycelium",        color: "#ddd6fe", tag: "Bio", roughness: 1.2, type: "organic", melt: 150 },
    { name: "Coral",           color: "#f87171", tag: "Bio", roughness: 1.3, type: "organic", melt: 900 },
    { name: "Glass",           color: "#e0f2fe", tag: "Si", roughness: 0.1, type: "glass", melt: 1400 },
    { name: "Concrete",        color: "#d4d4d8", tag: "Si", roughness: 0.9, type: "rock",  melt: 1500 },
    { name: "Asphalt",         color: "#18181b", tag: "C",  roughness: 0.7, type: "rock",  melt: 175 },
    { name: "Plastic",         color: "#22d3ee", tag: "C",  roughness: 0.2, type: "organic", melt: 160 },
    { name: "Wax",             color: "#fef9c3", tag: "C",  roughness: 0.4, type: "organic", melt: 60 },
    { name: "Ceramic",         color: "#ffedd5", tag: "Si", roughness: 0.6, type: "rock",  melt: 2000 },
];

function hexToHSL(hex) {
    let r = parseInt(hex.substring(1,3), 16) / 255;
    let g = parseInt(hex.substring(3,5), 16) / 255;
    let b = parseInt(hex.substring(5,7), 16) / 255;
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) { h = s = 0; } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h * 360, s: s * 100, l: l * 100 };
}

function hslToHex(h, s, l) {
    l /= 100;
    const a = s * Math.min(l, 1 - l) / 100;
    const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color).toString(16).padStart(2, '0');
    };
    return `#${f(0)}${f(8)}${f(4)}`;
}

function artColor(hex, lShift, sShift = 0, hShift = 0) {
    const hsl = hexToHSL(hex);
    let targetL = hsl.l + lShift;
    if (lShift > 0 && targetL > 85) {
        const excess = targetL - 85;
        targetL = 85 + (excess / (excess + 15)) * 12;
    }
    let newL = Math.max(5, Math.min(98, targetL));
    let newS = Math.max(0, Math.min(100, hsl.s + sShift));
    let newH = (hsl.h + hShift) % 360;
    if (newH < 0) newH += 360;
    return hslToHex(newH, newS, newL);
}

// Convert Hex to RGB Unit (0-1) for SVG Filters
function hexToRgbUnit(hex) {
    let r = parseInt(hex.substring(1,3), 16) / 255;
    let g = parseInt(hex.substring(3,5), 16) / 255;
    let b = parseInt(hex.substring(5,7), 16) / 255;
    return {r: r.toFixed(3), g: g.toFixed(3), b: b.toFixed(3)};
}

function createRNG(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash = hash & hash;
    }
    let seed = (hash >>> 0) || 1;
    return function() {
        seed |= 0;
        seed = seed + 0x6D2B79F5 | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

function getTagHtml(tag) {
    const colorMap = {
        'C': 'tag-c', 'H2O': 'tag-si', 'Bio': 'tag-bio',
        'Fe': 'tag-fe', 'Au': 'tag-fe', 'Cu': 'tag-fe', 'Ag': 'tag-fe', 'Pb': 'tag-fe', 'Sn': 'tag-fe', 'Al': 'tag-fe', 'Ti': 'tag-fe', 'W': 'tag-fe', 'Co': 'tag-fe',
        'Si': 'tag-fe', 'S': 'tag-fe', 'Na': 'tag-fe',
        'H': 'tag-si', 'He': 'tag-si', 'O': 'tag-si', 'N': 'tag-si', 'Ar': 'tag-si', 'Cl': 'tag-si', 'Br': 'tag-si', 'D2O': 'tag-si',
        'U': 'tag-x', 'Hg': 'tag-x', 'Ga': 'tag-x', 'X': 'tag-x'
    };
    return `<span class="tag ${colorMap[tag] || 'tag-none'}">${tag}</span>`;
}

/* --- STATE MANAGEMENT --- */
const state = {
    seed: 'INIT',
    data: null, 
    waterLevel: 50,
    shadow: 50,
    cloudsEnabled: true,
    autoRotate: true,
    // Generated palette storage
    currentPalette: [], 
    // 3D Physics
    rotationSpeed: 0.1,
    isDragging: false,
    dragStartX: 0,
    dragStartRotation: 0,
    velocity: 0.5,
    targetRotation: 0,
    
    // Inertia Tracking
    lastMouseX: 0,
    lastMouseTime: 0,
    dragVelocity: 0 // Velocity calculated during drag
};

/* --- DOM REFERENCES --- */
const dom = {
    defsSurface: document.getElementById('defs-surface'),
    defsHeight: document.getElementById('defs-height'),
    // Baker Groups
    bTerrain: document.getElementById('bake-group-terrain'),
    bLiquid: document.getElementById('bake-group-liquid'),
    bIce: document.getElementById('bake-group-ice'),
    bBio: document.getElementById('bake-group-bio'),
    bCraterOverlays: document.getElementById('bake-group-crater-overlays'), // NEW
    bHeight: document.getElementById('bake-group-height'), // NEW: Height map group
    bBg: document.getElementById('bake-bg'),
    // SVGs
    svgSurface: document.getElementById('surface-baker'),
    svgHeight: document.getElementById('height-baker'), // NEW: Height SVG
    // Inputs
    seedInput: document.getElementById('seed-input'),
    btnRnd: document.getElementById('btn-rnd'),
    btnGen: document.getElementById('btn-gen'),
    btnDownload: document.getElementById('btn-download'),
    rngWater: document.getElementById('rng-water'),
    rngShadow: document.getElementById('rng-shadow'),
    chkClouds: document.getElementById('chk-clouds'),
    chkAutoRotate: document.getElementById('chk-auto-rotate'),
    lblWater: document.getElementById('lbl-water'),
    lblShadow: document.getElementById('lbl-shadow'),
    // Readouts
    valTemp: document.getElementById('val-temp'),
    valLiquid: document.getElementById('val-liquid'),
    valSolid: document.getElementById('val-solid'),
    valAtmos: document.getElementById('val-atmos'),
    valLife: document.getElementById('val-life'),
};

/* --- THREE.JS SETUP --- */
const canvas = document.querySelector('#webgl-canvas');
const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
renderer.setSize(canvas.clientWidth, canvas.clientHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(40, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
camera.position.z = 3.8;

// Planet Group (Rotates)
const planetGroup = new THREE.Group();
scene.add(planetGroup);

// Sphere (Surface)
const geometry = new THREE.SphereGeometry(1, 512, 512); // Higher poly for smoothness
const material = new THREE.MeshStandardMaterial({ 
    roughness: 1.0, 
    metalness: 0.0,
    displacementScale: 0.1, // Scale for topography
});
const planetMesh = new THREE.Mesh(geometry, material);
planetGroup.add(planetMesh);

/* --- CLOUD SHADER SYSTEM --- */
const cloudVertexShader = `
    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec3 vViewPosition;

    void main() {
        vUv = uv;
        vNormal = normalize(normalMatrix * normal);
        vPosition = position; // Local position
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vViewPosition = -mvPosition.xyz;
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const cloudFragmentShader = `
    uniform float uTime;
    uniform vec3 uColor;
    uniform float uCoverage;
    uniform float uSeed;
    uniform vec3 uSunDir;
    
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec3 vViewPosition;

    // Simplex 3D Noise 
    // (MIT License, Stefan Gustavson)
    vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
    vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

    float snoise(vec3 v){ 
      const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
      const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
      vec3 i  = floor(v + dot(v, C.yyy) );
      vec3 x0 = v - i + dot(i, C.xxx) ;
      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min( g.xyz, l.zxy );
      vec3 i2 = max( g.xyz, l.zxy );
      vec3 x1 = x0 - i1 + C.xxx;
      vec3 x2 = x0 - i2 + C.yyy;
      vec3 x3 = x0 - D.yyy;
      i = mod(i, 289.0 ); 
      vec4 p = permute( permute( permute( 
                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
               + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
      float n_ = 1.0/7.0; // N=7
      vec3  ns = n_ * D.wyz - D.xzx;
      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,N*N)
      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
      vec4 x = x_ *ns.x + ns.yyyy;
      vec4 y = y_ *ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);
      vec4 b0 = vec4( x.xy, y.xy );
      vec4 b1 = vec4( x.zw, y.zw );
      vec4 s0 = floor(b0)*2.0 + 1.0;
      vec4 s1 = floor(b1)*2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));
      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
      vec3 p0 = vec3(a0.xy,h.x);
      vec3 p1 = vec3(a0.zw,h.y);
      vec3 p2 = vec3(a1.xy,h.z);
      vec3 p3 = vec3(a1.zw,h.w);
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;
      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                    dot(p2,x2), dot(p3,x3) ) );
    }

    float fbm(vec3 x) {
        float v = 0.0;
        float a = 0.5;
        vec3 shift = vec3(100.0);
        for (int i = 0; i < 4; ++i) {
            v += a * snoise(x);
            x = x * 2.0 + shift;
            a *= 0.5;
        }
        return v;
    }

    void main() {
        // Rotate noise domain slowly for flow
        float theta = uTime * 0.01; // Flow Speed
        mat3 rot = mat3(
            cos(theta), 0.0, sin(theta),
            0.0, 1.0, 0.0,
            -sin(theta), 0.0, cos(theta)
        );
        
        // --- CLUMPING LOGIC ---
        // Dense atmosphere (high coverage) = Smaller multiplier = Larger clumps
        // Thin atmosphere (low coverage) = Higher multiplier = Smaller wisps
        float clumpScale = 3.5 - (uCoverage * 1.5); 
        
        // Base seed offset
        vec3 pos = vPosition * clumpScale + vec3(uSeed * 10.0);
        pos = rot * pos; // Apply rotation to noise field

        float n = fbm(pos); 
        float val = n * 0.5 + 0.5; // 0..1 range

        // Density Logic
        // We raise the base threshold so clouds are inherently sparser/thinner
        float baseThreshold = 0.55; 
        float threshold = baseThreshold - (uCoverage * 0.25); 
        float softness = 0.2;
        
        float density = smoothstep(threshold, threshold + softness, val);
        
        // --- EDGE FADING (Fresnel) ---
        // Prevents the "flat" look at the edges of the sphere
        vec3 viewDir = normalize(vViewPosition);
        vec3 normal = normalize(vNormal);
        float NdotV = dot(normal, viewDir);
        float edgeFade = smoothstep(0.0, 0.35, NdotV); // Fade out as surface turns away

        // Lighting
        
        // Rim Light (Fresnel) - stronger on edges where cloud exists
        float rim = pow(1.0 - max(NdotV, 0.0), 3.0);
        
        // Diffuse Sun Light
        float diff = max(dot(normal, normalize(uSunDir)), 0.0);
        
        // Combine
        vec3 finalColor = uColor * (diff * 0.8 + 0.3) + (rim * 0.2);

        // Cap opacity to ensure translucency (never fully opaque white)
        // Combine density, coverage factor, and edge fade
        float finalAlpha = density * (uCoverage * 0.5 + 0.1) * edgeFade * 0.7; 

        gl_FragColor = vec4(finalColor, finalAlpha);
    }
`;

// Sphere (Volumetric Clouds)
const cloudGeo = new THREE.SphereGeometry(1.025, 128, 128);
const cloudMat = new THREE.ShaderMaterial({
    uniforms: {
        uTime: { value: 0.0 },
        uColor: { value: new THREE.Color(1, 1, 1) },
        uCoverage: { value: 0.5 },
        uSeed: { value: 0.0 },
        uSunDir: { value: new THREE.Vector3(5, 2, 5).normalize() }
    },
    vertexShader: cloudVertexShader,
    fragmentShader: cloudFragmentShader,
    transparent: true,
    side: THREE.DoubleSide,
    depthWrite: false
});
const cloudMesh = new THREE.Mesh(cloudGeo, cloudMat);
planetGroup.add(cloudMesh);

// Atmosphere Glow (Shader) - SOFT UPDATE
const atmosGeo = new THREE.SphereGeometry(1.25, 64, 64);
const atmosMat = new THREE.ShaderMaterial({
    uniforms: {
        glowColor: { type: "c", value: new THREE.Color(0x3b82f6) }
    },
    vertexShader: `
        varying vec3 vNormal;
        varying vec3 vViewDir;
        void main() {
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vViewDir = normalize(-mvPosition.xyz);
            gl_Position = projectionMatrix * mvPosition;
        }
    `,
    fragmentShader: `
        uniform vec3 glowColor;
        varying vec3 vNormal;
        varying vec3 vViewDir;
        void main() {
            // Calculate dot product (approx -1.0 at center, 0.0 at edge)
            float dotVal = dot(vNormal, vViewDir);
            
            // We want the glow to be strongest behind the planet (center) and fade to 0 at the edge.
            // Using -dotVal gives us 1.0 at center and 0.0 at edge.
            // Using power 3.0 ensures a very smooth falloff to absolute zero at the edge.
            float intensity = pow(clamp(-dotVal, 0.0, 1.0), 3.0);
            
            // Soften the result significantly (0.5 max opacity)
            gl_FragColor = vec4(glowColor, intensity * 0.5);
        }
    `,
    side: THREE.BackSide,
    blending: THREE.AdditiveBlending,
    transparent: true,
    depthWrite: false
});
const atmosMesh = new THREE.Mesh(atmosGeo, atmosMat);
planetGroup.add(atmosMesh);

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.02); // Start dark
scene.add(ambientLight);
const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
sunLight.position.set(5, 2, 5);
scene.add(sunLight);

/* --- RESIZE HANDLER --- */
const updateCamera = () => {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const aspect = w / h;
    
    camera.aspect = aspect;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
    
    // Fit planet logic (Radius 1)
    // Base distance 3.8 works for standard Landscape (Aspect ~1.7)
    // For Portrait (<1), we need to distance the camera to fit the width.
    const baseZ = 3.8;
    camera.position.z = aspect < 1.0 ? baseZ / aspect : baseZ;
};
window.addEventListener('resize', updateCamera);

/* --- GENERATION HELPERS --- */

// Re-creates the full 18-step palette for deep terrain detail
function generateDeepPalette(hex) {
    const s = hex;
    return [
        artColor(s, -30, 0, -15),
        artColor(s, -30, 0, -15),
        artColor(s, -22, 4, -10),
        artColor(s, -15, 8, -6),
        artColor(s, -4, 16, -2),
        artColor(s, 0, 14, 0),
        s,
        s,
        s,
        artColor(s, 4, 14, 1),
        artColor(s, 6, 16, 3),
        artColor(s, 11, 22, 5),
        artColor(s, 13, 24, 7),
        artColor(s, 13, 24, 7),
        artColor(s, 15, 28, 11),
        artColor(s, 15, 28, 11),
        artColor(s, 15, 28, 11),
        artColor(s, 21, 32, 13),
        artColor(s, 21, 32, 13),
        artColor(s, 28, 34, 16)
    ];
}

/**
 * HELPER: Updates the Color Map Filter based on Water Level
 * This "stretches" the terrain palette to fit the dry land exactly.
 */
function updateTerrainColormap() {
    if (!state.currentPalette || state.currentPalette.length === 0) return;

    const filterId = `terrain-map-${state.seed}`;
    const filter = document.getElementById(filterId);
    if (!filter) return;

    const waterLvl = state.waterLevel / 100; // 0.0 to 1.0
    const palette = state.currentPalette;
    const pLen = palette.length;
    
    // We create a high-res lookup table (256 entries) to map Input Luminance -> Output Color
    const steps = 256;
    const rVals = [], gVals = [], bVals = [];

    for (let i = 0; i < steps; i++) {
        // The current pixel's height (0.0 to 1.0)
        const lum = i / (steps - 1);

        let colorHex;

        if (lum < waterLvl) {
            // CASE A: Underwater
            // We map this to the lowest terrain color.
            colorHex = palette[0]; 
        } else {
            // CASE B: Land
            // We re-normalize the height so that "Sea Level" = 0.0 and "Peak" = 1.0
            const validRange = 1.0 - waterLvl;
            
            // Calculate relative height (0.0 at shore, 1.0 at max peak)
            let relativeH = 0;
            if (validRange > 0.001) {
                relativeH = (lum - waterLvl) / validRange;
            }

            // Map this relative height to the palette index
            const pIndex = Math.floor(relativeH * pLen);
            const safeIndex = Math.min(pLen - 1, Math.max(0, pIndex));
            colorHex = palette[safeIndex];
        }

        const rgb = hexToRgbUnit(colorHex);
        rVals.push(rgb.r);
        gVals.push(rgb.g);
        bVals.push(rgb.b);
    }

    // Apply the calculated table to the SVG Filter
    const funcs = filter.querySelectorAll('feFuncR, feFuncG, feFuncB');
    if (funcs.length === 3) {
        funcs[0].setAttribute('type', 'discrete');
        funcs[1].setAttribute('type', 'discrete');
        funcs[2].setAttribute('type', 'discrete');
        
        funcs[0].setAttribute('tableValues', rVals.join(' '));
        funcs[1].setAttribute('tableValues', gVals.join(' '));
        funcs[2].setAttribute('tableValues', bVals.join(' '));
    }
}

/**
 * UPDATED HEIGHT MAP GENERATION
 * Generates height curves based on planet roughness and zone (ice vs terrain).
 * Allows for distinct topographical profiles (steep cliffs vs rolling dunes).
 */
function updateHeightMap() {
    if (!state.currentPalette) return;

    const waterLvl = state.waterLevel / 100; // 0.0 to 1.0
    const steps = 256;
    const roughness = state.data.roughness || 1.0;
    
    // Use palette size to create discrete height steps
    const paletteLen = state.currentPalette.length;
    // We only start vertical displacement after the "shadow" tiers of the palette (index 0-5)
    // This ensures the "sub-surface" or "wet" parts of the land stay flat.
    const deformationStart = 6; 

    // Filter IDs
    const terrainFilterId = `height-filter-terrain-${state.seed}`;
    const iceFilterId = `height-filter-ice-${state.seed}`;

    // Curve calculation
    // Soft (low roughness) -> Higher exponent (rises slowly, needs more space)
    // Rough (high roughness) -> Lower exponent (rises quickly, needs less space)
    // Range: roughness 0.5 -> exp ~2.9 | roughness 2.0 -> exp ~1.1
    const terrainExp = Math.max(0.5, 3.5 - (roughness * 1.2));
    const iceExp = 2.5; 

    const computeValues = (exponent, isIce) => {
        const values = [];
        for (let i = 0; i < steps; i++) {
            const lum = i / (steps - 1);
            if (lum < waterLvl) {
                values.push(0);
            } else {
                const range = 1.0 - waterLvl;
                let normalizedH = range > 0.001 ? (lum - waterLvl) / range : 0;
                
                let heightVal = 0;
                
                if (isIce) {
                    // Ice stays smooth/continuous usually
                     heightVal = Math.pow(normalizedH, exponent);
                } else {
                    // Discretize normalizedH to match palette tiers
                    let tier = Math.floor(normalizedH * paletteLen);
                    if (tier >= paletteLen) tier = paletteLen - 1;
                    
                    if (tier < deformationStart) {
                        // "Sub-surface" tiers stay flat
                        heightVal = 0;
                    } else {
                        // Calculate progress through the remaining "active" tiers
                        const effectiveTier = tier - deformationStart;
                        const activeTiers = (paletteLen - 1) - deformationStart;
                        const progress = activeTiers > 0 ? effectiveTier / activeTiers : 1;
                        
                        heightVal = Math.pow(progress, exponent);
                    }
                }
                
                values.push(heightVal.toFixed(3));
            }
        }
        return values.join(' ');
    };

    const terrainValues = computeValues(terrainExp, false);
    const iceValues = computeValues(iceExp, true);

    const tFilter = document.getElementById(terrainFilterId);
    if (tFilter) {
        const funcs = tFilter.querySelectorAll('feFuncR, feFuncG, feFuncB');
        funcs.forEach(f => {
            f.setAttribute('type', 'discrete');
            f.setAttribute('tableValues', terrainValues);
        });
    }

    const iFilter = document.getElementById(iceFilterId);
    if (iFilter) {
        const funcs = iFilter.querySelectorAll('feFuncR, feFuncG, feFuncB');
        funcs.forEach(f => {
            f.setAttribute('type', 'discrete');
            f.setAttribute('tableValues', iceValues);
        });
    }
}

async function bakeSVGToTexture(svgElement) {
    const xml = new XMLSerializer().serializeToString(svgElement);
    const blob = new Blob([xml], {type: "image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            const tex = new THREE.Texture(img);
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            
            // --- FIX FOR SEAMS ---
            // RepeatWrapping ensures the left edge blends into the right edge 
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.ClampToEdgeWrapping;
            
            tex.needsUpdate = true;
            URL.revokeObjectURL(url);
            resolve(tex);
        };
        img.src = url;
    });
}

function generateCratersSVG(rng, count) {
    if (count <= 0) return "";
    
    // Instead of drawing individual craters with gradients, we draw 
    // clusters of black shapes that define the "Hole".
    // A separate filter will then expand these shapes to create the "Rim".
    
    let els = "";
    
    for (let i = 0; i < count; i++) {
        // Main Position
        const cx = Math.floor(rng() * 2048);
        const cy = Math.floor(rng() * 1024);
        
        // Base Radius: Power law distribution
        const rBase = rng(); 
        let r = 0;
        if(rBase > 0.98) r = 40 + rng() * 60; // Huge basin
        else if(rBase > 0.9) r = 20 + rng() * 30; // Large crater
        else r = 4 + rng() * 15; // Common crater

        // Aspect ratio correction for polar stretching
        const lat = Math.abs(cy - 512) / 512;
        const stretch = (1 + lat * lat * 2);

        // Amorphous Logic: Draw multiple ellipses near this center to create a non-round shape
        // Number of blobs in this crater cluster
        const blobs = Math.floor(rng() * 3) + 1; 

        for (let j = 0; j < blobs; j++) {
            // Offset from center (First blob is always center)
            const angle = rng() * Math.PI * 2;
            const dist = j === 0 ? 0 : rng() * r * 0.5;
            
            const bx = cx + Math.cos(angle) * dist;
            const by = cy + Math.sin(angle) * dist;

            // Varying sub-radius
            const subR = r * (0.2 + rng() * 1);
            
            const rx = subR * stretch;
            const ry = subR;

            // Draw Hole Shape (Fill needs to be opaque for the filter to work on alpha)
            const el = `<ellipse cx="${bx}" cy="${by}" rx="${rx}" ry="${ry}" fill="#000" />`;
            els += el;

            // Wrap X (if close to edges)
            if (bx < rx) {
                els += `<ellipse cx="${bx + 2048}" cy="${by}" rx="${rx}" ry="${ry}" fill="#000" />`;
            } else if (bx > 2048 - rx) {
                els += `<ellipse cx="${bx - 2048}" cy="${by}" rx="${rx}" ry="${ry}" fill="#000" />`;
            }
        }
    }
    
    // Return a group with the shapes. The parent logic will wrap this in a filter.
    return `<g>${els}</g>`;
}

function generatePlanetData(rng) {
    let baseTemp = Math.floor(rng() * 450 - 150);
    if (rng() > 0.92) baseTemp += Math.floor(rng() * 4500);
    if (rng() < 0.12) baseTemp -= 150;
    const equatorOffset = Math.floor(rng() * 50 + 20);
    const poleOffset = Math.floor(rng() * 80 + 40);
    const maxT = baseTemp + equatorOffset;
    const minT = baseTemp - poleOffset;
    const validSolids = SOLIDS.filter(s => {
        if (s.type === 'ice' && baseTemp > s.melt) return false;
        return true;
    });
    let solid = validSolids.length > 0 ? validSolids[Math.floor(rng() * validSolids.length)] : { name: "Scorched Crust", color: "#1a0500", tag: "Si", roughness: 1.2, type: "rock", melt: 9999 };
    const solidMeltK = solid.melt + 273.15;
    let solidName = solid.name;
    const baseK = baseTemp + 273.15;
    if (baseK > solidMeltK * 3) {
        solidName = `Molten ${solid.name}`;
        solid = { ...solid, color: artColor(solid.color, 8, 5, 5) };
    }
    const potentialLiquids = LIQUIDS.filter(l => baseTemp > l.freeze);
    let liquid, oceanName, liquidState = "none", cloudColor, atmosContribution = 0;
    if (potentialLiquids.length > 0) {
        liquid = potentialLiquids[Math.floor(rng() * potentialLiquids.length)];
        oceanName = liquid.name;
        cloudColor = liquid.cloud;
        const liquidBoilK = liquid.boil + 273.15;
        if (baseK > liquidBoilK * 3) {
            liquidState = "sediment";
            oceanName = `${liquid.name} Sediment`;
            liquid = { ...liquid, color: artColor(liquid.color, -40, -30), tag: "Dry" };
            cloudColor = "#59544f"; 
            atmosContribution = 0.8;
        } else if (baseK > liquidBoilK) {
            liquidState = "boiling";
            oceanName = `Boiling ${liquid.name}`;
            atmosContribution = 0.4;
        } else {
            liquidState = "liquid";
            atmosContribution = 0.1; 
        }
    } else {
        liquidState = "none";
        oceanName = "None";
        liquid = { name: "None", tag: "-", frozenColor: "#a1a1aa", cloud: "#a1a1aa" };
        cloudColor = "#a1a1aa";
    }
    let atmosName = "None", atmosDensity = 0;
    if (rng() > 0.2) { 
        atmosDensity = rng() * 0.3; 
        atmosDensity += atmosContribution;
        // Cap atmos density slightly lower to prevent 100% whiteout
        atmosDensity = Math.max(0, Math.min(0.95, atmosDensity)); 
        if (liquidState === "sediment") {
            atmosDensity = 0.9 + (rng() * 0.1);
            atmosName = `Dense Vaporized ${liquid.name}`;
        } else if (atmosDensity < 0.05) {
            atmosName = "Trace Gases";
        } else {
            const desc = atmosDensity > 0.7 ? "Dense" : atmosDensity > 0.35 ? "Moderate" : "Thin";
            const gas = (liquid.gas && liquidState !== "none") ? liquid.gas : "Inert Mix";
            atmosName = `${desc} ${gas}`;
        }
    } else {
        atmosName = "Vacuum";
    }
    
    // IMPACT LOGIC: No/Thin Atmosphere = More Craters
    let craterCount = 0;
    if (atmosDensity < 0.15) {
        const densityFactor = 1 - (atmosDensity / 0.15); // 0 to 1
        // Very roughly 20 to 150 craters
        craterCount = Math.floor(20 + (rng() * 30 * densityFactor));
    }

    let hasLife = false, lifeType = "None", bioColor = null, bioMinT = 0, bioMaxT = 0;
    if (liquidState === "liquid") {
        if (liquid.tag === "H2O" && baseTemp > -20 && baseTemp < 80) {
            hasLife = true; lifeType = "Carbon-Based"; bioColor = "#10b981"; bioMinT = -20; bioMaxT = 80;
        } else if (solid.tag === "Si" && baseTemp > 400 && baseTemp < 1200) {
            hasLife = true; lifeType = "Silicon-Based"; bioColor = "#9333ea"; bioMinT = 400; bioMaxT = 1200;
        } else if (liquid.tag === "C" && baseTemp < -100) {
            hasLife = true; lifeType = "Hydrocarbon-Based"; bioColor = "#f43f5e"; bioMinT = -200; bioMaxT = -100;
        } else if (solid.tag === "U" || solid.tag === "X") {
            hasLife = true; lifeType = "Radiotrophic"; bioColor = "#bef264"; bioMinT = baseTemp - 50; bioMaxT = baseTemp + 50;
        }
    }
    const getLatForTemp = (t) => (maxT === minT) ? 0.5 : (maxT - t) / (maxT - minT);
    let latBoil = getLatForTemp(liquid.boil || 9999);
    let latFreeze = getLatForTemp(liquid.freeze || 9998);
    if (liquidState === "sediment") latBoil = -2.0;
    let suggestedWater = (liquidState === "none" || liquidState === "sediment") ? Math.floor(rng() * 15) : Math.floor(rng() * 40 + 30);
    if (hasLife) suggestedWater = Math.floor(rng() * 20 + 45);

    // CLOUD PARAMETERS
    // Higher temp = more turbulence. Density = more coverage.
    const cloudTurbulence = Math.min(1.0, Math.max(0.0, (baseTemp + 100) / 400));
    const cloudCoverage = atmosDensity;

    return {
        baseTemp, maxT, minT, solid, liquid, latBoil, latFreeze, oceanName, solidName, atmosName, atmosDensity,
        cloudHex: cloudColor, hasLife, lifeType, bioColor, bioMinT, bioMaxT, rings: rng() < 0.15,
        baseFreq: 0.006 - ((solid.roughness * 0.5) * 0.0045), suggestedWater, roughness: solid.roughness * (0.5 + rng()),
        craterCount,
        cloudTurbulence, cloudCoverage
    };
}

async function fullRebuild() {
    dom.btnGen.disabled = true;
    dom.btnGen.innerText = "Simulating...";
    
    // Clear SVGs
    dom.bTerrain.innerHTML = '';
    dom.bLiquid.innerHTML = '';
    dom.bIce.innerHTML = '';
    dom.bBio.innerHTML = '';
    dom.bHeight.innerHTML = ''; // Clear height
    dom.bCraterOverlays.innerHTML = ''; // Clear overlay
    
    // Clear dynamic defs from BOTH surfaces
    dom.defsSurface.querySelectorAll('.dynamic-def').forEach(el => el.remove());
    dom.defsHeight.querySelectorAll('.dynamic-def').forEach(el => el.remove());

    const rng = createRNG(state.seed);
    state.data = generatePlanetData(rng);
    const data = state.data;
    
    // SAVE PALETTE TO STATE
    state.currentPalette = generateDeepPalette(data.solid.color); 

    // Update Text UI with Ranges and Tags
    dom.valTemp.innerHTML = `${data.baseTemp}Â°C <span class="temp-range">(<span class="t-min">${data.minT}Â°</span> / <span class="t-max">${data.maxT}Â°</span>)</span>`;
    dom.valLiquid.innerHTML = data.oceanName + getTagHtml(data.liquid.tag);
    dom.valSolid.innerHTML = data.solidName + getTagHtml(data.solid.tag);
    dom.valAtmos.innerText = data.atmosName;
    dom.valLife.innerHTML = data.hasLife ? data.lifeType : "STERILE";
    dom.valLife.className = data.hasLife ? "data-val tag-life" : "data-val tag-dead";

    // Update Atmosphere Glow Color
    atmosMat.uniforms.glowColor.value.set(data.cloudHex);
    atmosMesh.visible = true;

    // 1. GENERATE NOISE PATTERN (TILED 1024x1024)
    // We must generate unique IDs for patterns in both SVGs or duplicate the content.
    // For simplicity, we add the noise filter and pattern to BOTH defs.
    
    const noiseID = `noise-${state.seed}`;
    const noiseFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    noiseFilter.setAttribute("id", noiseID);
    noiseFilter.setAttribute("x", "0%"); noiseFilter.setAttribute("y", "0%"); 
    noiseFilter.setAttribute("width", "100%"); noiseFilter.setAttribute("height", "100%");
    noiseFilter.classList.add('dynamic-def');
    
    // REDUCED CONTRAST for Height Map data integrity (was slope 3, now 1.5)
    noiseFilter.innerHTML = `
        <feTurbulence type="fractalNoise" baseFrequency="${data.baseFreq}" numOctaves="6" seed="${Math.floor(rng()*100)}" stitchTiles="stitch" result="turb"/>
        <feColorMatrix type="saturate" values="0" in="turb" result="gray"/>
        <feComponentTransfer in="gray" result="contrasted">
            <feFuncR type="linear" slope="1.5" intercept="-0.25"/>
            <feFuncG type="linear" slope="1.5" intercept="-0.25"/>
            <feFuncB type="linear" slope="1.5" intercept="-0.25"/>
        </feComponentTransfer>
    `;
    
    // Append to BOTH
    dom.defsSurface.appendChild(noiseFilter.cloneNode(true));
    dom.defsHeight.appendChild(noiseFilter.cloneNode(true));

    const noisePatternId = `pat-noise-${state.seed}`;
    const pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
    pattern.setAttribute("id", noisePatternId);
    pattern.setAttribute("patternUnits", "userSpaceOnUse");
    pattern.setAttribute("width", "1024"); pattern.setAttribute("height", "1024");
    pattern.classList.add('dynamic-def');
    pattern.innerHTML = `<rect width="1024" height="1024" filter="url(#${noiseID})"/>`;
    
    // Append to BOTH
    dom.defsSurface.appendChild(pattern.cloneNode(true));
    dom.defsHeight.appendChild(pattern.cloneNode(true));

    // 2. TERRAIN COLOR FILTER (Surface Only)
    const mapFilterId = `terrain-map-${state.seed}`;
    const mapFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    mapFilter.setAttribute("id", mapFilterId);
    mapFilter.classList.add('dynamic-def');
    mapFilter.innerHTML = `
        <feComponentTransfer>
            <feFuncR type="discrete" tableValues="0"/>
            <feFuncG type="discrete" tableValues="0"/>
            <feFuncB type="discrete" tableValues="0"/>
        </feComponentTransfer>
    `;
    dom.defsSurface.appendChild(mapFilter);

    // Call our new updater immediately to set initial colors
    updateTerrainColormap();

    // CRATER GENERATION (SYNCED & BLENDED)
    let craterImgStr = "";
    
    if (data.craterCount > 0) {
        // Generate the group of amorphous hole shapes
        const shapes = generateCratersSVG(rng, data.craterCount);
        
        // Define the sophisticated composite filter
        // 1. DILATE the hole shapes to find the Rim Area
        // 2. EXCLUDE the original hole shapes from the Rim Area
        // 3. COLOR the Hole Dark Grey (Depth)
        // 4. COLOR the Rim White (Height)
        const filterDef = `
            <filter id="complex-crater-filter" x="-20%" y="-20%" width="140%" height="140%">
                <!-- GENERATE NOISE -->
                <feTurbulence type="fractalNoise" baseFrequency="0.03" numOctaves="3" seed="${Math.floor(rng()*100)}" result="noise"/>
                
                <!-- DISPLACE HOLE SHAPE (Skewing/Imperfection) -->
                <feDisplacementMap in="SourceAlpha" in2="noise" scale="8" xChannelSelector="R" yChannelSelector="G" result="distortedAlpha"/>
                <feGaussianBlur in="distortedAlpha" stdDeviation="2" result="softHole"/>

                <!-- GENERATE RIM MASK -->
                <feMorphology in="SourceAlpha" operator="dilate" radius="3" result="dilated"/>
                <feComposite in="dilated" in2="SourceAlpha" operator="out" result="rimMask"/>
                <!-- Displace Rim independently so it matches the vibe but isn't identical -->
                <feDisplacementMap in="rimMask" in2="noise" scale="6" result="distortedRimRaw"/>
                <feGaussianBlur in="distortedRimRaw" stdDeviation="3" result="softRim"/>

                <!-- COLOR HOLE: TEXTURED DARKNESS -->
                <!-- We use the noise to create a rocky floor texture -->
                <feColorMatrix type="matrix" values="0.2 0 0 0 0  0.2 0 0 0 0  0.2 0 0 0 0  0 0 0 1 0" in="noise" result="darkRock"/>
                <feComposite in="darkRock" in2="softHole" operator="in" result="finalHole"/>

                <!-- COLOR RIM: White -->
                <feFlood flood-color="#ffffff" flood-opacity="0.6" result="colRim"/> 
                <feComposite in="colRim" in2="softRim" operator="in" result="finalRim"/>

                <!-- MERGE -->
                <feMerge>
                    <feMergeNode in="finalHole"/>
                    <feMergeNode in="finalRim"/>
                </feMerge>
            </filter>
        `;

        // Wrap it in a standalone SVG for feImage
        const fullHeightSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="2048" height="1024">
            <defs>${filterDef}</defs>
            <g filter="url(#complex-crater-filter)">${shapes}</g>
        </svg>`;
        
        const base64SVG = btoa(fullHeightSVG);
        craterImgStr = `data:image/svg+xml;base64,${base64SVG}`;
    }

    // --- TERRAIN CONSTRUCTION (COLOR) ---
    const tGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    tGroup.setAttribute("filter", `url(#${mapFilterId})`);
    
    const terrainRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    terrainRect.setAttribute("x", "-100");
    terrainRect.setAttribute("width", "2248"); 
    terrainRect.setAttribute("height", "1024");
    terrainRect.setAttribute("fill", `url(#${noisePatternId})`);
    tGroup.appendChild(terrainRect);
    
    if (data.craterCount > 0) {
        // Craters for Surface Visuals
        // Using "Hard-Light" blend mode:
        // Dark Grey Hole -> Darkens terrain
        // White Rim -> Lightens terrain
        // Transparent -> No change
        const cWrapper = document.createElementNS("http://www.w3.org/2000/svg", "image");
        cWrapper.setAttribute("href", craterImgStr);
        cWrapper.setAttribute("width", "2048");
        cWrapper.setAttribute("height", "1024");
        cWrapper.style.mixBlendMode = "hard-light"; 
        tGroup.appendChild(cWrapper);

        // --- NEW: OVERLAY FOR WATER DEPTH ---
        // This ensures the crater hole darkens the liquid above it
        // We use multiply to ensure the dark parts of the crater affect the water
        const cOverlay = cWrapper.cloneNode(true);
        cOverlay.style.mixBlendMode = "multiply"; 
        cOverlay.style.opacity = "0.7"; 
        dom.bCraterOverlays.appendChild(cOverlay);
    }
    dom.bTerrain.appendChild(tGroup);

    // --- HEIGHT MAP GENERATION (Height SVG Only) ---
    // Create filters with optional crater integration via feBlend

    const createHeightFilter = (id) => {
        const f = document.createElementNS("http://www.w3.org/2000/svg", "filter");
        f.setAttribute("id", id);
        f.classList.add('dynamic-def');
        
        let src = "SourceGraphic";
        let html = "";
        
        // Inject craters via feImage + feBlend if they exist
        // This ensures the height map deformation sees the crater shape before mapping to steps
        if (data.craterCount > 0 && craterImgStr) {
             html += `<feImage href="${craterImgStr}" x="0" y="0" width="2048" height="1024" result="craters" preserveAspectRatio="none"/>`;
             html += `<feBlend in="craters" in2="SourceGraphic" mode="hard-light" result="blended"/>`;
             src = "blended";
        }
        
        html += `
        <feComponentTransfer in="${src}">
            <feFuncR type="discrete" tableValues="0"/>
            <feFuncG type="discrete" tableValues="0"/>
            <feFuncB type="discrete" tableValues="0"/>
        </feComponentTransfer>`;
        
        f.innerHTML = html;
        return f;
    };

    const heightFilterTerrainId = `height-filter-terrain-${state.seed}`;
    dom.defsHeight.appendChild(createHeightFilter(heightFilterTerrainId));

    const heightFilterIceId = `height-filter-ice-${state.seed}`;
    dom.defsHeight.appendChild(createHeightFilter(heightFilterIceId));
    
    updateHeightMap(); // Set initial tables

    // 1. Terrain Height Group
    const hGroupTerrain = document.createElementNS("http://www.w3.org/2000/svg", "g");
    hGroupTerrain.setAttribute("filter", `url(#${heightFilterTerrainId})`);
    // This rect uses noise pattern. Pattern must exist in defsHeight.
    hGroupTerrain.appendChild(terrainRect.cloneNode(true));
    // NOTE: We do NOT append craters here anymore; they are integrated in the filter.
    dom.bHeight.appendChild(hGroupTerrain);
    
    // 3. LIQUID / ICE MASKS (Used for Color)
    const lMaskId = `filter-mask-liq-${state.seed}`;
    const lFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    lFilter.setAttribute("id", lMaskId);
    lFilter.classList.add('dynamic-def');
    lFilter.innerHTML = `<feComponentTransfer><feFuncR type="linear" slope="1" intercept="0" /><feFuncG type="linear" slope="1" intercept="0" /><feFuncB type="linear" slope="1" intercept="0" /></feComponentTransfer>`;
    dom.defsSurface.appendChild(lFilter);

    const liqMask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
    liqMask.setAttribute("id", `mask-liq-${state.seed}`);
    liqMask.classList.add('dynamic-def');
    
    const maskGroup = tGroup.cloneNode(true); 
    maskGroup.removeAttribute("filter"); 
    maskGroup.setAttribute("filter", `url(#${lMaskId})`); 
    
    liqMask.appendChild(maskGroup);
    dom.defsSurface.appendChild(liqMask);

    // Liquid Rect
    const lRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    lRect.setAttribute("x", "-100");
    lRect.setAttribute("width","2248"); 
    lRect.setAttribute("height","1024");
    lRect.setAttribute("fill", data.liquid.color);
    lRect.setAttribute("mask", `url(#mask-liq-${state.seed})`);
    if(data.liquid.type !== "magma") lRect.setAttribute("filter", "url(#liquid-blur)");
    dom.bLiquid.appendChild(lRect);

    // Ice Zone Logic
    const zoneGradId = `grad-zones-${state.seed}`;
    const zoneGrad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    zoneGrad.setAttribute("id", zoneGradId);
    zoneGrad.setAttribute("x1", "0"); zoneGrad.setAttribute("y1", "0"); zoneGrad.setAttribute("x2", "0"); zoneGrad.setAttribute("y2", "1"); 
    zoneGrad.classList.add('dynamic-def');
    const fTop = (0.5 - data.latFreeze*0.5)*100;
    const fBot = (0.5 + data.latFreeze*0.5)*100;
    zoneGrad.innerHTML = `<stop offset="0%" stop-color="#fff"/><stop offset="${fTop}%" stop-color="#fff"/><stop offset="${fTop}%" stop-color="#000"/><stop offset="${fBot}%" stop-color="#000"/><stop offset="${fBot}%" stop-color="#fff"/><stop offset="100%" stop-color="#fff"/>`;
    
    // Add to BOTH
    dom.defsSurface.appendChild(zoneGrad.cloneNode(true));
    dom.defsHeight.appendChild(zoneGrad.cloneNode(true));

    // Ice Mask
    const iceZoneMaskId = `mask-ice-zone-${state.seed}`;
    const izMask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
    izMask.setAttribute("id", iceZoneMaskId);
    izMask.classList.add('dynamic-def');
    // NOTE: zone-warp must be present in both SVGs static defs for this to work
    izMask.innerHTML = `<rect width="2048" height="1024" fill="url(#${zoneGradId})" filter="url(#zone-warp)"/>`;
    dom.defsSurface.appendChild(izMask.cloneNode(true));
    
    // For Height Mask, we need a clone that points to the same filter (which exists in both)
    const izMaskH = izMask.cloneNode(true);
    // Ensure it uses the height-specific zone warp if we named it differently, but we named both #zone-warp in HTML
    dom.defsHeight.appendChild(izMaskH);
    
    // Ice Surface Visuals
    const iGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    iGroup.setAttribute("mask", `url(#${iceZoneMaskId})`);
    const iRect = lRect.cloneNode(); 
    iRect.setAttribute("fill", data.liquid.frozenColor);
    iRect.setAttribute("filter", ""); 
    iGroup.appendChild(iRect);
    dom.bIce.appendChild(iGroup);

    // 2b. ICE HEIGHT GROUP
    const hGroupIce = document.createElementNS("http://www.w3.org/2000/svg", "g");
    hGroupIce.setAttribute("filter", `url(#${heightFilterIceId})`);
    hGroupIce.setAttribute("mask", `url(#${iceZoneMaskId})`); 
    
    const iceHRect = terrainRect.cloneNode(true);
    hGroupIce.appendChild(iceHRect);
    // Craters integrated via filter
    dom.bHeight.appendChild(hGroupIce);

    // 5. POLAR CAP MASK (Fixes pinch artifacts at poles)
    // Overlays a gradient on the height map to force displacement to 0 at poles
    const polarGradId = `grad-polar-${state.seed}`;
    const polarGrad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    polarGrad.setAttribute("id", polarGradId);
    polarGrad.setAttribute("x1", "0"); polarGrad.setAttribute("y1", "0");
    polarGrad.setAttribute("x2", "0"); polarGrad.setAttribute("y2", "1");
    polarGrad.classList.add('dynamic-def');
    polarGrad.innerHTML = `
        <stop offset="0%" stop-color="#000" stop-opacity="1"/>
        <stop offset="2%" stop-color="#000" stop-opacity="0"/>
        <stop offset="98%" stop-color="#000" stop-opacity="0"/>
        <stop offset="100%" stop-color="#000" stop-opacity="1"/>
    `;
    dom.defsHeight.appendChild(polarGrad);

    const polarCapRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    polarCapRect.setAttribute("width", "2048");
    polarCapRect.setAttribute("height", "1024");
    polarCapRect.setAttribute("fill", `url(#${polarGradId})`);
    dom.bHeight.appendChild(polarCapRect);

    // 4. CLOUDS (Volumetric Update)
    if (state.cloudsEnabled && data.atmosDensity > 0.05) {
        // Feed shader uniforms
        cloudMat.uniforms.uColor.value.set(data.cloudHex);
        cloudMat.uniforms.uCoverage.value = data.atmosDensity;
        cloudMat.uniforms.uSeed.value = rng();
        cloudMesh.visible = true;
    } else {
        cloudMesh.visible = false;
    }

    // UPDATE THREE.JS TEXTURES
    softUpdate(true); 
    
    // Bake Surface Color
    const surfaceTex = await bakeSVGToTexture(dom.svgSurface);
    material.map = surfaceTex;
    
    // Bake Height Map (for Topography)
    const heightTex = await bakeSVGToTexture(dom.svgHeight);
    material.displacementMap = heightTex;
    // material.displacementScale is set in softUpdate based on roughness
    material.needsUpdate = true;
    
    // Reset Tilt
    planetMesh.rotation.z = 0;
    cloudMesh.rotation.z = 0;

    dom.btnGen.disabled = false;
    dom.btnGen.innerText = "Re-Generate";
}

function softUpdate(isGenerating = false) {
    const waterFactor = state.waterLevel / 100;
    
    // Update terrain colors based on new sea level
    updateTerrainColormap();
    
    // Update displacement (height) based on new sea level and roughness
    updateHeightMap();

    // Physically scale displacement based on planet roughness
    // Increased Multiplier for visibility
    const roughness = state.data ? state.data.roughness : 1.0;
    material.displacementScale = 0.05 + (roughness * 0.15);

    // Update Liquid Mask Threshold
    const lMaskId = `filter-mask-liq-${state.seed}`;
    const slope = -50;
    const intercept = (waterFactor * 50) + 0.5; 
    
    const f = document.getElementById(lMaskId);
    if(f) {
        const funcs = f.querySelectorAll('feFuncR, feFuncG, feFuncB');
        funcs.forEach(el => {
            el.setAttribute('slope', slope);
            el.setAttribute('intercept', intercept);
        });
    }

    // Update Lighting from Shadow Slider
    const sunIntensity = (100 - state.shadow) / 50 * 2.0;
    const ambientIntensity = (state.shadow) / 100 * 0.4; // More ambient in "shadowy" settings
    sunLight.intensity = Math.max(0.1, sunIntensity);
    ambientLight.intensity = Math.max(0.02, ambientIntensity);
    
    // Clouds Visibility
    cloudMesh.visible = state.cloudsEnabled && (state.data ? state.data.atmosDensity > 0.05 : false);

    if (!isGenerating) {
        // Re-bake Surface Color
        bakeSVGToTexture(dom.svgSurface).then(tex => {
            if(material.map) material.map.dispose();
            material.map = tex;
            material.needsUpdate = true;
        });
        
        // Re-bake Height Map (Topography)
        bakeSVGToTexture(dom.svgHeight).then(tex => {
            if(material.displacementMap) material.displacementMap.dispose();
            material.displacementMap = tex;
            material.needsUpdate = true;
        });
    }
}

/* --- INTERACTION (DRAG & SPIN) --- */
function initInteraction() {
    const stage = document.getElementById('stage');
    
    const handleStart = (x) => {
        state.isDragging = true;
        state.dragStartX = x;
        state.dragStartRotation = planetGroup.rotation.y;
        
        state.velocity = 0;
        state.autoRotate = false;
        dom.chkAutoRotate.checked = false;
        state.targetRotation = planetGroup.rotation.y;
        
        // Reset Inertia tracking
        state.lastMouseX = x;
        state.lastMouseTime = Date.now();
        state.dragVelocity = 0;
    };

    const handleMove = (x) => {
        if (!state.isDragging) return;
        
        const now = Date.now();
        const deltaX = x - state.dragStartX;
        const sensitivity = 0.005;
        state.targetRotation = state.dragStartRotation + (deltaX * sensitivity);

        // Calculate velocity for inertia
        const dt = now - state.lastMouseTime;
        if (dt > 0) {
            const dx = x - state.lastMouseX;
            // Calculate rotational velocity: radians per frame (approx 16ms)
            // Multiplier tweaks the "heaviness"
            state.dragVelocity = (dx * sensitivity); 
        }

        state.lastMouseX = x;
        state.lastMouseTime = now;
    };

    const handleEnd = () => {
        state.isDragging = false;
        
        // Apply the calculated velocity from the drag motion
        // If user holds still before releasing, dt will be large in the next frame check
        // or velocity will be old. We decay it if too old.
        const timeSinceMove = Date.now() - state.lastMouseTime;
        if (timeSinceMove > 50) {
            state.velocity = 0;
        } else {
            state.velocity = state.dragVelocity;
        }
    };

    // Mouse
    stage.addEventListener('mousedown', e => handleStart(e.clientX));
    window.addEventListener('mousemove', e => handleMove(e.clientX));
    window.addEventListener('mouseup', handleEnd);
    stage.addEventListener('mouseleave', handleEnd);

    // Touch
    stage.addEventListener('touchstart', e => handleStart(e.touches[0].clientX));
    window.addEventListener('touchmove', e => handleMove(e.touches[0].clientX));
    window.addEventListener('touchend', handleEnd);
}

/* --- ANIMATION LOOP --- */
function animate() {
    requestAnimationFrame(animate);

    // Update Cloud Shader Time (Simulates weather systems moving)
    cloudMat.uniforms.uTime.value += 0.005;
    
    // Rotate Cloud sphere slightly faster for wind simulation
    cloudMesh.rotation.y += 0.0003;

    if (state.isDragging) {
        // Snappy follow with slight smoothing
        planetGroup.rotation.y += (state.targetRotation - planetGroup.rotation.y) * 0.3;
    } else {
        if (state.autoRotate) {
            planetGroup.rotation.y += 0.001; 
        } else {
            // Apply inertia
            planetGroup.rotation.y += state.velocity;
            
            // Friction/Decay
            state.velocity *= 0.95;
            
            // Stop if too slow
            if (Math.abs(state.velocity) < 0.00001) state.velocity = 0;
        }
    }

    renderer.render(scene, camera);
}

/* --- INITIALIZATION --- */
window.onload = () => {
    // Handlers
    const triggerRebuild = () => {
        state.seed = dom.seedInput.value.toUpperCase();
        state.waterLevel = parseInt(dom.rngWater.value);
        state.shadow = parseInt(dom.rngShadow.value);
        state.cloudsEnabled = dom.chkClouds.checked;
        state.autoRotate = dom.chkAutoRotate.checked;
        fullRebuild();
    }

    dom.btnRnd.addEventListener('click', () => {
        const pfx = ["TERRA", "AQUA", "MAGMA", "CRYO", "XENO", "LUNA", "SOL"];
        dom.seedInput.value = `${pfx[Math.floor(Math.random()*pfx.length)]}-${Math.floor(Math.random()*9999)}`;
        const tmpRng = createRNG(dom.seedInput.value);
        const tmpData = generatePlanetData(tmpRng);
        dom.rngWater.value = tmpData.suggestedWater;
        dom.lblWater.innerText = tmpData.suggestedWater + '%';
        triggerRebuild();
    });

    dom.btnGen.addEventListener('click', triggerRebuild);
    dom.seedInput.addEventListener('change', triggerRebuild);
    dom.rngWater.addEventListener('change', () => { 
        state.waterLevel = parseInt(dom.rngWater.value);
        dom.lblWater.innerText = state.waterLevel + '%';
        softUpdate();
    });
    dom.rngWater.addEventListener('input', () => dom.lblWater.innerText = dom.rngWater.value + '%');

    dom.rngShadow.addEventListener('input', () => {
        state.shadow = parseInt(dom.rngShadow.value);
        dom.lblShadow.innerText = state.shadow + '%';
        softUpdate();
    });

    dom.chkClouds.addEventListener('change', () => {
        state.cloudsEnabled = dom.chkClouds.checked;
        softUpdate();
    });
    
    dom.chkAutoRotate.addEventListener('change', () => {
        state.autoRotate = dom.chkAutoRotate.checked;
    });

    dom.btnDownload.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `PLANETMAP_${state.seed}.png`;
        link.href = material.map.image.src;
        link.click();
    });

    // Init
    initInteraction();
    updateCamera();
    const initRng = createRNG(dom.seedInput.value);
    const initData = generatePlanetData(initRng);
    dom.rngWater.value = initData.suggestedWater;
    dom.lblWater.innerText = initData.suggestedWater + '%';
    triggerRebuild();
    animate();
};
</script>
</body>
</html>
