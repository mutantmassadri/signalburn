<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SB PLANETGEN V10.1 - SEAMLESS ROTATION</title>
    <style>
        /* --- CORE VISUALS --- */
        :root {
            --c-bg: #050507;
            --c-panel: #141416;
            --c-border: #27272a;
            --c-accent: #3b82f6;
            --c-accent-glow: rgba(59, 130, 246, 0.5);
            --c-text: #e4e4e7;
            --c-text-dim: #a1a1aa;
            
            --f-mono: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
            --f-sans: system-ui, -apple-system, sans-serif;
        }

        * { box-sizing: border-box; outline: none; }

        body {
            background-color: var(--c-bg);
            color: var(--c-text);
            font-family: var(--f-sans);
            margin: 0;
            height: 100vh;
            display: grid;
            grid-template-columns: 1fr 380px;
            overflow: hidden;
        }

        /* --- LEFT: CANVAS AREA --- */
        .stage {
            position: relative;
            background: radial-gradient(circle at 50% 50%, #1a1a20 0%, #000 90%);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .stars { position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 0; pointer-events: none; }
        .star {
            position: absolute; background: white; border-radius: 50%; opacity: 0;
            animation: flicker 4s infinite ease-in-out;
        }
        @keyframes flicker {
            0% { opacity: 0.1; transform: scale(0.5); }
            50% { opacity: 0.8; transform: scale(1); }
            100% { opacity: 0.1; transform: scale(0.5); }
        }

        #render-target {
            width: 95vmin; height: 95vmin;
            z-index: 10;
            filter: drop-shadow(0 0 50px rgba(0,0,0,0.8));
            will-change: transform; 
        }

        /* --- RIGHT: CONTROL DECK --- */
        .deck {
            background: var(--c-panel);
            border-left: 1px solid var(--c-border);
            padding: 0;
            display: flex; flex-direction: column;
            overflow-y: auto;
            box-shadow: -10px 0 40px rgba(0,0,0,0.5);
            z-index: 20;
        }

        .deck-header {
            padding: 20px;
            border-bottom: 1px solid var(--c-border);
            background: rgba(0,0,0,0.2);
        }

        h1 {
            font-family: var(--f-mono);
            font-size: 1.1rem;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--c-accent);
            text-shadow: 0 0 15px var(--c-accent-glow);
            display: flex; justify-content: space-between;
        }
        .version { font-size: 0.7em; opacity: 0.5; color: white; }

        .seed-row { display: flex; gap: 8px; }

        input[type="text"] {
            background: var(--c-bg); border: 1px solid var(--c-border); color: var(--c-text);
            font-family: var(--f-mono); padding: 12px; border-radius: 6px; flex: 1;
            font-size: 0.9rem; transition: border 0.2s;
        }
        input[type="text"]:focus { border-color: var(--c-accent); }

        .btn-icon {
            width: 44px; background: var(--c-bg); border: 1px solid var(--c-border);
            color: var(--c-text); border-radius: 6px; cursor: pointer; font-size: 1.2rem;
            transition: all 0.2s;
        }
        .btn-icon:hover { background: var(--c-border); color: #fff; }

        .controls { padding: 20px; display: flex; flex-direction: column; gap: 20px; }

        .section-title {
            font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1.5px;
            color: var(--c-text-dim); font-weight: 700; margin-bottom: 12px;
            display: flex; align-items: center; gap: 8px;
        }
        .section-title::after { content: ''; flex: 1; height: 1px; background: var(--c-border); }

        .btn-action {
            width: 100%; padding: 16px;
            background: linear-gradient(135deg, var(--c-accent) 0%, #2563eb 100%);
            border: none; color: white; font-weight: bold; text-transform: uppercase;
            letter-spacing: 1px; border-radius: 8px; cursor: pointer;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
            transition: transform 0.1s;
        }
        .btn-action:active { transform: scale(0.98); }

        /* DATA READOUT PANEL */
        .data-panel {
            background: #0f0f11; border: 1px solid var(--c-border);
            border-radius: 6px; padding: 12px; font-family: var(--f-mono); font-size: 0.75rem;
            display: grid; gap: 8px;
        }
        .data-row { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px dashed #27272a; padding-bottom: 4px; }
        .data-row:last-child { border-bottom: none; }
        .data-lbl { color: var(--c-text-dim); }
        .data-val { color: var(--c-text); font-weight: bold; text-align: right;}
        
        .tag { font-size: 0.7em; padding: 2px 4px; border-radius: 3px; margin-left: 5px; opacity: 0.9; }
        .tag-c { background: #064e3b; color: #6ee7b7; border: 1px solid #059669; }
        .tag-si { background: #312e81; color: #a5b4fc; border: 1px solid #4f46e5; }
        .tag-fe { background: #451a03; color: #fdba74; border: 1px solid #c2410c; }
        .tag-x { background: #4c1d95; color: #e9d5ff; border: 1px solid #8b5cf6; }
        .tag-bio { background: #831843; color: #f9a8d4; border: 1px solid #db2777; }
        .tag-none { background: #27272a; color: #a1a1aa; border: 1px solid #3f3f46; }

        .tag-life { color: #10b981; text-shadow: 0 0 10px rgba(16,185,129,0.3); font-weight: bold; }
        .tag-dead { color: var(--c-text-dim); opacity: 0.5; }

        /* SLIDERS */
        .slider-group { margin-bottom: 12px; }
        .slider-header {
            display: flex; justify-content: space-between; font-size: 0.8rem;
            margin-bottom: 6px; color: var(--c-text-dim);
        }
        input[type="range"] {
            -webkit-appearance: none; width: 100%; height: 6px;
            background: #27272a; border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%;
            background: var(--c-text); cursor: pointer; border: 2px solid var(--c-bg);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .toggle-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 0; font-size: 0.9rem;
        }
        .switch { position: relative; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-switch {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #27272a; border-radius: 24px; transition: .3s;
        }
        .slider-switch:before {
            position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px;
            background-color: #a1a1aa; border-radius: 50%; transition: .3s;
        }
        input:checked + .slider-switch { background-color: var(--c-accent); }
        input:checked + .slider-switch:before { transform: translateX(20px); background-color: white; }

        .dl-group { margin-top: auto; padding: 24px; border-top: 1px solid var(--c-border); }
        .btn-dl {
            width: 100%; padding: 12px; background: transparent; border: 1px solid var(--c-border);
            color: var(--c-text); border-radius: 6px; cursor: pointer; font-family: var(--f-mono);
            font-size: 0.8rem; display: flex; align-items: center; justify-content: center; gap: 10px;
        }
        .btn-dl:hover { background: #27272a; }

        /* --- RESPONSIVE LAYOUT --- */
        @media (max-width: 800px) {
            body {
                grid-template-columns: 1fr;
                grid-template-rows: minmax(0, 1fr) auto;
                height: 100vh;
                overflow: hidden;
            }

            .deck {
                border-left: none;
                border-top: 1px solid var(--c-border);
                box-shadow: 0 -10px 40px rgba(0,0,0,0.5);
                max-height: 45vh;
                overflow-y: auto;
            }

            #render-target {
                width: 90vmin;
                height: 90vmin;
            }

            .dl-group {
                margin-top: 12px;
                padding-top: 12px;
                padding-bottom: 12px;
            }
        }

    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.4",
    "react-dom/": "https://esm.sh/react-dom@^19.2.4/",
    "react/": "https://esm.sh/react@^19.2.4/"
  }
}
</script>
</head>
<body>

    <div class="stage" id="stage">
        <div class="stars" id="starfield"></div>
        
        <svg id="render-target" viewBox="-200 -200 1400 1400" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <clipPath id="planet-clip">
                    <circle cx="500" cy="500" r="450" />
                </clipPath>

                <filter id="geo-blur" x="-20%" y="-20%" width="140%" height="140%">
                    <feGaussianBlur stdDeviation="25" />
                </filter>

                <filter id="liquid-blur" x="-20%" y="-20%" width="140%" height="140%">
                    <feGaussianBlur stdDeviation="1" />
                </filter>
                
                <!-- Updated Filters for Static usage -->
                <filter id="soft-atmos">
                    <feGaussianBlur stdDeviation="30" />
                </filter>

                <filter id="blur-shadow">
                    <feGaussianBlur stdDeviation="20" />
                </filter>
                
                <!-- Pre-defined lens gradient (used in JS generator) -->
                <radialGradient id="static-lens-grad">
                    <stop offset="0%" stop-color="#808080" />
                    <stop offset="100%" stop-color="#000000" />
                </radialGradient>
            </defs>

            <g id="layer-rings-back"></g>

            <circle id="planet-halo" cx="500" cy="500" r="453" fill="#111115" />

            <g id="planet-sphere" clip-path="url(#planet-clip)">
                
                <!-- The Tilt Group rotates the axis of the planet -->
                <g id="planet-axis-group">
                    
                    <!-- The Lens Distortion Filter is applied here (Static) -->
                    <g id="planet-lens-container">
                        
                        <!-- The Slider moves the infinite texture strip horizontally (Hardware Accelerated) -->
                        <g id="planet-surface-slider">
                            <g id="group-terrain"></g>
                            <g id="group-liquid"></g>
                            <g id="group-ice" style="mix-blend-mode: normal;"></g>
                            <g id="group-bio"></g>
                            <g id="geo-structure-layer"></g> <!-- Vectors -->
                        </g>
                        
                    </g>
                    
                    <!-- Clouds are handled separately to allow for parallax -->
                    <g id="layer-clouds-rotator"></g>

                </g>

            </g>

            <circle id="atmos-glow" cx="500" cy="500" r="450" fill="url(#grad-atmos)" pointer-events="none" style="mix-blend-mode: screen;"/>
            <circle id="rim-light" cx="500" cy="500" r="448" fill="none" stroke="#fff" stroke-width="3" opacity="0.4" pointer-events="none"/>

            <circle id="shadow-overlay" cx="500" cy="500" r="450" fill="url(#shadow-grad)" pointer-events="none"/>
            <path id="terminator" d="" fill="#08080a" opacity="0.6" filter="url(#blur-shadow)" style="mix-blend-mode: multiply;" pointer-events="none"/>
            
            <g id="layer-rings-front"></g>

        </svg>
    </div>

    <div class="deck">
        <div class="deck-header">
            <h1>SB PLANETGEN <span class="version">V10.2</span></h1>
            <div class="seed-row">
                <input type="text" id="seed-input" value="AQUA-VITA">
                <button class="btn-icon" id="btn-rnd" title="Randomize">ðŸŽ²</button>
            </div>
        </div>

        <div class="controls">
            
            <div class="data-panel" id="data-panel">
                <div class="data-row"><span class="data-lbl">Temperature:</span> <span class="data-val" id="val-temp">--</span></div>
                <div class="data-row"><span class="data-lbl">Surface:</span> <span class="data-val" id="val-solid">--</span></div>
                <div class="data-row"><span class="data-lbl">Fluid:</span> <span class="data-val" id="val-liquid">--</span></div>
                <div class="data-row"><span class="data-lbl">Atmosphere:</span> <span class="data-val" id="val-atmos">--</span></div>
                <div class="data-row"><span class="data-lbl">Biology:</span> <span class="data-val tag-dead" id="val-life">NONE DETECTED</span></div>
            </div>

            <div>
                <div class="section-title">Manual Override</div>
                
                <div class="slider-group">
                    <div class="slider-header">
                        <span>Sea Level</span>
                        <span id="lbl-water">50%</span>
                    </div>
                    <input type="range" id="rng-water" min="0" max="100" value="50">
                </div>

                <div class="slider-group">
                    <div class="slider-header">
                        <span>Planet Rotation (3D)</span>
                        <span id="lbl-rotation">0Â°</span>
                    </div>
                    <input type="range" id="rng-rotation" min="0" max="360" value="0">
                </div>

                <div class="toggle-row">
                    <span>Show Clouds</span>
                    <label class="switch">
                        <input type="checkbox" id="chk-clouds" checked>
                        <span class="slider-switch"></span>
                    </label>
                </div>
            </div>

            <div>
                <div class="section-title">Lighting</div>
                <div class="slider-group">
                    <div class="slider-header">
                        <span>Shadow Intensity</span>
                        <span id="lbl-shadow">50%</span>
                    </div>
                    <input type="range" id="rng-shadow" min="0" max="95" value="50">
                </div>
            </div>
            
            <button class="btn-action" id="btn-gen">Update View</button>

        </div>

        <div class="dl-group">
            <button class="btn-dl" id="btn-download">
                <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg>
                Download Vector SVG
            </button>
        </div>
    </div>

<script>
/**
 * SB PLANETGEN V10.2 - PERFORMANCE & SAFARI FIX
 * - Replaced Canvas Data URI with SVG Vector Data URI for Lens Map (Safari Fix)
 * - Implemented Sliding Texture Strip via Transforms (Performance Fix)
 * - Removed per-frame filter updates (Seam Fix)
 */

const LIQUIDS = [
    { name: "Water",       color: "#3b82f6", freeze: 0,    boil: 100,  tag: "C",  cloud: "#ffffff", frozenColor: "#e0f2fe", type: "standard", gas: "Water Vapor" },
    { name: "Salt Water",  color: "#2563eb", freeze: -2,   boil: 102,  tag: "C",  cloud: "#f1f5f9", frozenColor: "#bfdbfe", type: "standard", gas: "Water Vapor" },
    { name: "Heavy Water", color: "#60a5fa", freeze: 3.8,  boil: 101,  tag: "C",  cloud: "#e0f2fe", frozenColor: "#93c5fd", type: "standard", gas: "Deuterium" },
    { name: "Peroxide",    color: "#7dd3fc", freeze: -0.4, boil: 150,  tag: "O",  cloud: "#e0f2fe", frozenColor: "#e0f2fe", type: "standard", gas: "Oxygen" },
    { name: "Vinegar",     color: "#fde047", freeze: -2,   boil: 118,  tag: "C",  cloud: "#fef9c3", frozenColor: "#facc15", type: "acid",     gas: "Acetic Acid" },
    { name: "Brine",       color: "#0284c7", freeze: -21,  boil: 108,  tag: "C",  cloud: "#f0f9ff", frozenColor: "#bae6fd", type: "standard", gas: "Chlorine" },
    { name: "Methane",     color: "#38bdf8", freeze: -182, boil: -161, tag: "C",  cloud: "#bae6fd", frozenColor: "#bae6fd", type: "volatile", gas: "Methane" },
    { name: "Ethane",      color: "#0ea5e9", freeze: -183, boil: -88,  tag: "C",  cloud: "#e0f2fe", frozenColor: "#7dd3fc", type: "volatile", gas: "Ethane" },
    { name: "Nitrogen",    color: "#60a5fa", freeze: -210, boil: -195, tag: "N",  cloud: "#f1f5f9", frozenColor: "#93c5fd", type: "volatile", gas: "Nitrogen" },
    { name: "Ammonia",     color: "#2dd4bf", freeze: -77,  boil: -33,  tag: "N",  cloud: "#ccfbf1", frozenColor: "#5eead4", type: "acid",     gas: "Ammonia" },
    { name: "Chlorine",    color: "#a3e635", freeze: -101, boil: -34,  tag: "Cl", cloud: "#d9f99d", frozenColor: "#84cc16", type: "acid",     gas: "Chlorine Gas" },
    { name: "Sulfuric Acid", color: "#facc15", freeze: 10,  boil: 337,  tag: "S",  cloud: "#fef08a", frozenColor: "#eab308", type: "acid",    gas: "Sulfur Dioxide" },
    { name: "Nitric Acid",   color: "#fb7185", freeze: -42, boil: 83,   tag: "N",  cloud: "#fca5a5", frozenColor: "#f43f5e", type: "acid",    gas: "Nitrogen Dioxide" },
    { name: "Lava",        color: "#ff4500", freeze: 700,  boil: 3000, tag: "Si", cloud: "#57534e", frozenColor: "#292524", type: "magma",    gas: "Silicate Vapor" },
    { name: "Mercury",     color: "#cbd5e1", freeze: -39,  boil: 357,  tag: "Fe", cloud: "#e2e8f0", frozenColor: "#94a3b8", type: "metal",    gas: "Mercury Vapor" },
    { name: "Crude Oil",   color: "#020617", freeze: -57,  boil: 200,  tag: "C",  cloud: "#52525b", frozenColor: "#000000", type: "viscous",  gas: "Petroleum Gas" },
    { name: "Blood",       color: "#dc2626", freeze: -2,   boil: 100,  tag: "Bio",cloud: "#fca5a5", frozenColor: "#991b1b", type: "organic",  gas: "Iron Oxide" },
    { name: "Slime",       color: "#86efac", freeze: 0,    boil: 110,  tag: "Bio",cloud: "#bbf7d0", frozenColor: "#22c55e", type: "organic",  gas: "Methane" },
];

const SOLIDS = [
    { name: "Silicate",   color: "#78716c", tag: "Si", roughness: 1.0, type: "rock", melt: 1200 },
    { name: "Basalt",     color: "#3f3f46", tag: "Si", roughness: 1.0, type: "rock", melt: 1100 },
    { name: "Granite",    color: "#a1a1aa", tag: "Si", roughness: 1.3, type: "rock", melt: 1215 },
    { name: "Sandstone",  color: "#f59e0b", tag: "Si", roughness: 0.5, type: "rock", melt: 1300 },
    { name: "Limestone",  color: "#e5e5e5", tag: "C",  roughness: 0.8, type: "rock", melt: 900 },
    { name: "Obsidian",   color: "#18181b", tag: "Si", roughness: 1.1, type: "glass", melt: 1000 },
    { name: "Pumice",     color: "#d4d4d8", tag: "Si", roughness: 1.5, type: "rock", melt: 1200 },
    { name: "Regolith",   color: "#737373", tag: "Si", roughness: 1.4, type: "dust", melt: 1200 },
    { name: "Slate",      color: "#475569", tag: "Si", roughness: 0.9, type: "rock", melt: 1200 },
    { name: "Marble",     color: "#f3f4f6", tag: "C",  roughness: 0.7, type: "rock", melt: 1200 },
    { name: "Water Ice",  color: "#e2e8f0", tag: "C",  roughness: 0.7, type: "ice", melt: 0 },
    { name: "Dry Ice",    color: "#eff6ff", tag: "C",  roughness: 0.4, type: "ice", melt: -78 },
    { name: "Blue Ice",   color: "#bfdbfe", tag: "C",  roughness: 0.9, type: "ice", melt: 0 },
    { name: "Methane Ice",color: "#7dd3fc", tag: "C",  roughness: 0.5, type: "ice", melt: -182 },
    { name: "Iron Ore",   color: "#b91c1c", tag: "Fe", roughness: 1.2, type: "metal", melt: 1538 },
    { name: "Gold Vein",  color: "#facc15", tag: "Fe", roughness: 1.0, type: "metal", melt: 1064 },
    { name: "Copper Ox",  color: "#34d399", tag: "Fe", roughness: 0.8, type: "metal", melt: 1085 },
    { name: "Titanium",   color: "#94a3b8", tag: "Fe", roughness: 0.9, type: "metal", melt: 1668 },
    { name: "Bone",       color: "#fef3c7", tag: "Bio", roughness: 0.9, type: "organic", melt: 200 }
];

function hexToHSL(hex) {
    let r = parseInt(hex.substring(1,3), 16) / 255;
    let g = parseInt(hex.substring(3,5), 16) / 255;
    let b = parseInt(hex.substring(5,7), 16) / 255;
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) { h = s = 0; } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h * 360, s: s * 100, l: l * 100 };
}

function hslToHex(h, s, l) {
    l /= 100;
    const a = s * Math.min(l, 1 - l) / 100;
    const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color).toString(16).padStart(2, '0');
    };
    return `#${f(0)}${f(8)}${f(4)}`;
}

function artColor(hex, lShift, sShift = 0, hShift = 0) {
    const hsl = hexToHSL(hex);
    let newL = Math.max(6, Math.min(95, hsl.l + lShift));
    let newS = Math.max(0, Math.min(100, hsl.s + sShift));
    let newH = (hsl.h + hShift) % 360;
    if (newH < 0) newH += 360;
    return hslToHex(newH, newS, newL);
}

function createRNG(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash = hash & hash;
    }
    let seed = (hash >>> 0) || 1;
    return function() {
        seed |= 0;
        seed = seed + 0x6D2B79F5 | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

const state = {
    seed: 'INIT',
    data: null, 
    waterLevel: 50,
    shadow: 50,
    cloudsEnabled: true,
    rotation: 0, 
    layerThresholds: []
};

const dom = {
    svg: document.getElementById('render-target'),
    defs: document.querySelector('defs'),
    gAxis: document.getElementById('planet-axis-group'),
    gLensContainer: document.getElementById('planet-lens-container'),
    gSurfaceSlider: document.getElementById('planet-surface-slider'),
    gTerrain: document.getElementById('group-terrain'),
    gLiquid: document.getElementById('group-liquid'),
    gIce: document.getElementById('group-ice'),
    gBio: document.getElementById('group-bio'),
    gCloudsRotator: document.getElementById('layer-clouds-rotator'),
    gGeoStructure: document.getElementById('geo-structure-layer'),
    gRingsBack: document.getElementById('layer-rings-back'),
    gRingsFront: document.getElementById('layer-rings-front'),
    rimLight: document.getElementById('rim-light'),
    terminator: document.getElementById('terminator'),
    seedInput: document.getElementById('seed-input'),
    btnRnd: document.getElementById('btn-rnd'),
    btnGen: document.getElementById('btn-gen'),
    btnDownload: document.getElementById('btn-download'),
    rngWater: document.getElementById('rng-water'),
    rngRotation: document.getElementById('rng-rotation'),
    rngShadow: document.getElementById('rng-shadow'),
    chkClouds: document.getElementById('chk-clouds'),
    lblWater: document.getElementById('lbl-water'),
    lblRotation: document.getElementById('lbl-rotation'),
    lblShadow: document.getElementById('lbl-shadow'),
    valTemp: document.getElementById('val-temp'),
    valLiquid: document.getElementById('val-liquid'),
    valSolid: document.getElementById('val-solid'),
    valAtmos: document.getElementById('val-atmos'),
    valLife: document.getElementById('val-life'),
};

/**
 * REPLACEMENT for canvas-based lens. 
 * Generates a pure SVG data URI which is safer for Safari and faster.
 */
function createSVGLensURI(strength) {
    // We construct a simple SVG string with a radial gradient
    // This mimics the displacement map: 50% gray is neutral, white/black are displacements.
    // For a sphere lens, we want neutral at center (maybe) or a gradient.
    // Actually, the previous canvas code did: 127 + (nx * d * strength).
    // A radial gradient from White to Black approximates the 'd' (distance) component.
    // To replicate the exact "bulge", a standard radial gradient is usually sufficient for art.
    const svg = `
    <svg xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256">
        <defs>
            <radialGradient id="g" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stop-color="#808080"/> <!-- Neutral-ish middle -->
                <stop offset="100%" stop-color="#ffffff"/> <!-- Maximum displace at edge -->
            </radialGradient>
        </defs>
        <rect width="256" height="256" fill="url(#g)"/>
    </svg>`;
    return "data:image/svg+xml;base64," + btoa(svg);
}

function generatePlanetData(rng) {
    let baseTemp = Math.floor(rng() * 450 - 150);
    if (rng() > 0.92) baseTemp += Math.floor(rng() * 4500);
    if (rng() < 0.12) baseTemp -= 150;
    const equatorOffset = Math.floor(rng() * 50 + 20);
    const poleOffset = Math.floor(rng() * 80 + 40);
    const maxT = baseTemp + equatorOffset;
    const minT = baseTemp - poleOffset;
    const CtoK = (c) => c + 273.15;
    const baseK = CtoK(baseTemp);
    const validSolids = SOLIDS.filter(s => {
        if (s.type === 'ice' && baseTemp > s.melt) return false;
        return true;
    });
    let solid = validSolids.length > 0 ? validSolids[Math.floor(rng() * validSolids.length)] : { name: "Scorched Crust", color: "#1a0500", tag: "Si", roughness: 1.2, type: "rock", melt: 9999 };
    const solidMeltK = CtoK(solid.melt);
    let solidName = solid.name;
    if (baseK > solidMeltK * 3) {
        solidName = `Molten ${solid.name}`;
        solid = { ...solid, color: artColor(solid.color, 25, 15, 5) };
    }
    const potentialLiquids = LIQUIDS.filter(l => baseTemp > l.freeze);
    let liquid, oceanName, liquidState = "none", cloudColor, atmosContribution = 0;
    if (potentialLiquids.length > 0) {
        liquid = potentialLiquids[Math.floor(rng() * potentialLiquids.length)];
        oceanName = liquid.name;
        cloudColor = liquid.cloud;
        const liquidBoilK = CtoK(liquid.boil);
        if (baseK > liquidBoilK * 3) {
            liquidState = "sediment";
            oceanName = `${liquid.name} Sediment`;
            liquid = { ...liquid, color: artColor(liquid.color, -40, -30), tag: "Dry" };
            cloudColor = "#59544f"; 
            atmosContribution = 0.8;
        } else if (baseK > liquidBoilK) {
            liquidState = "boiling";
            oceanName = `Boiling ${liquid.name}`;
            atmosContribution = 0.4;
        } else {
            liquidState = "liquid";
            atmosContribution = 0.1; 
        }
    } else {
        liquidState = "none";
        oceanName = "None";
        liquid = { name: "None", tag: "-", frozenColor: "#a1a1aa", cloud: "#a1a1aa" };
        cloudColor = "#a1a1aa";
    }
    let atmosName = "None", atmosDensity = 0;
    if (rng() > 0.2) { 
        atmosDensity = rng() * 0.3; 
        atmosDensity += atmosContribution;
        atmosDensity = Math.max(0, Math.min(1, atmosDensity)); 
        if (liquidState === "sediment") {
            atmosDensity = 0.9 + (rng() * 0.1);
            atmosName = `Dense Vaporized ${liquid.name}`;
        } else if (atmosDensity < 0.05) {
            atmosName = "Trace Gases";
        } else {
            const desc = atmosDensity > 0.7 ? "Dense" : atmosDensity > 0.35 ? "Moderate" : "Thin";
            const gas = (liquid.gas && liquidState !== "none") ? liquid.gas : "Inert Mix";
            atmosName = `${desc} ${gas}`;
        }
    } else {
        atmosName = "Vacuum";
    }
    let hasLife = false, lifeType = "None", bioColor = null, bioMinT = 0, bioMaxT = 0;
    if (liquidState === "liquid") {
        if (["Water", "Salt Water"].includes(liquid.name) && baseTemp > -15 && baseTemp < 60) {
            hasLife = true; lifeType = "Carbon-Based"; bioColor = "#10b981";
            bioMinT = -15; bioMaxT = 60;
        } else if (baseTemp > 200 && baseTemp < 1000 && solid.tag === "Si") {
            hasLife = true; lifeType = "Silicon-Based"; bioColor = "#9333ea";
            bioMinT = 200; bioMaxT = 1000;
        }
    }
    const getLatForTemp = (t) => (maxT === minT) ? 0.5 : (maxT - t) / (maxT - minT);
    let latBoil = getLatForTemp(liquid.boil || 9999);
    let latFreeze = getLatForTemp(liquid.freeze || 9998);
    if (liquidState === "sediment") latBoil = -2.0;
    let suggestedWater = (liquidState === "none" || liquidState === "sediment") ? Math.floor(rng() * 15) : Math.floor(rng() * 40 + 30);
    if (hasLife) suggestedWater = Math.floor(rng() * 20 + 45);
    return {
        baseTemp, maxT, minT, solid, liquid, latBoil, latFreeze, oceanName, solidName, atmosName, atmosDensity,
        cloudHex: cloudColor, hasLife, lifeType, bioColor, bioMinT, bioMaxT, tilt: rng() * 45, rings: rng() < 0.10,
        baseFreq: 0.006 - ((solid.roughness * 0.5) * 0.0045), suggestedWater, roughness: solid.roughness * (0.5 + rng())
    };
}

function generatePalette(data) {
    const s = data.solid.color;
    return [
        artColor(s, -45, 10, -15), artColor(s, -30, 5, -10), artColor(s, -15, 0, -5), s,
        artColor(s, 15, 0, 5), artColor(s, 30, -10, 10), artColor(s, 50, -20, 15)
    ];
}

function getTagHtml(tag) {
    const map = { 'C':'tag-c', 'Si':'tag-si', 'Fe':'tag-fe', 'X':'tag-x', 'N':'tag-none', 'O':'tag-none', 'S':'tag-fe', 'Bio':'tag-bio' };
    const cls = map[tag] || 'tag-none';
    return `<span class="tag ${cls}">[${tag}]</span>`;
}

function fullRebuild() {
    const rng = createRNG(state.seed);
    state.data = generatePlanetData(rng);
    const data = state.data;
    const palette = generatePalette(data);

    dom.valTemp.innerHTML = `${data.baseTemp}Â°C <span style="font-size: 0.8em; opacity: 0.7;">(<span style="color: #60a5fa">${data.minT}Â°</span> / <span style="color: #f87171">${data.maxT}Â°</span>)</span>`;
	dom.valLiquid.innerHTML = data.oceanName + getTagHtml(data.liquid.tag);
    dom.valSolid.innerHTML = data.solidName + getTagHtml(data.solid.tag);
    dom.valAtmos.innerText = data.atmosName;
    
    if(data.hasLife) {
        dom.valLife.innerHTML = data.lifeType;
        dom.valLife.className = "data-val tag-life";
    } else {
        dom.valLife.innerText = "STERILE";
        dom.valLife.className = "data-val tag-dead";
    }

    const noiseID = `noise-${state.seed}`;
    const structID = `struct-${state.seed}`;
    const lensData = createSVGLensURI(100); 
    
    dom.defs.querySelectorAll('.dynamic-def').forEach(el => el.remove());
    dom.gTerrain.innerHTML = '';
    dom.gLiquid.innerHTML = '';
    dom.gIce.innerHTML = '';
    dom.gBio.innerHTML = '';
    dom.gCloudsRotator.innerHTML = ''; 
    dom.gGeoStructure.innerHTML = '';
    dom.gRingsBack.innerHTML = '';
    dom.gRingsFront.innerHTML = '';

    dom.gAxis.setAttribute("transform", `rotate(${data.tilt}, 500, 500)`);

    // --- STATIC LENS FILTER ---
    // This filter is applied to the container. It uses userSpaceOnUse to remain centered.
    const lensFilterID = `lens-${state.seed}`;
    const lensFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    lensFilter.setAttribute("id", lensFilterID);
    lensFilter.setAttribute("x", "0"); lensFilter.setAttribute("y", "0");
    lensFilter.setAttribute("width", "1000"); lensFilter.setAttribute("height", "1000");
    lensFilter.setAttribute("filterUnits", "userSpaceOnUse");
    lensFilter.classList.add('dynamic-def');
    
    lensFilter.innerHTML = `
        <feImage href="${lensData}" result="lensMap" width="1000" height="1000" />
        <feDisplacementMap in="SourceGraphic" in2="lensMap" scale="100" xChannelSelector="R" yChannelSelector="G" />
    `;
    dom.defs.appendChild(lensFilter);
    dom.gLensContainer.setAttribute("filter", `url(#${lensFilterID})`);

    // --- NOISE GENERATION FILTER ---
    // Generates the texture. Tiled 3x horizontally to allow seamless scrolling.
    const masterFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    masterFilter.setAttribute("id", noiseID);
    masterFilter.setAttribute("x", "0%"); masterFilter.setAttribute("y", "0%");
    masterFilter.setAttribute("width", "100%"); masterFilter.setAttribute("height", "100%");
    masterFilter.classList.add('dynamic-def');
    
    // Note: We stitchTiles to ensure the 1000x1000 noise block loops perfectly.
    masterFilter.innerHTML = `
        <feTurbulence type="fractalNoise" baseFrequency="${data.baseFreq}" numOctaves="8" seed="${Math.floor(rng() * 1000)}" 
            stitchTiles="stitch" width="1000" height="1000" result="turb"/>
        <feTile in="turb" result="tiledTurb"/>
        <feColorMatrix type="saturate" values="0" in="tiledTurb" result="bw"/>
        <feComponentTransfer in="bw" result="contrasted">
            <feFuncR type="linear" slope="4" intercept="-1.5"/>
            <feFuncG type="linear" slope="4" intercept="-1.5"/>
            <feFuncB type="linear" slope="4" intercept="-1.5"/>
        </feComponentTransfer>
    `;
    dom.defs.appendChild(masterFilter);
	
    // Cloud Filter
    const cloudFilterID = `cloud-atmos-${state.seed}`;
    const cloudFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    cloudFilter.setAttribute("id", cloudFilterID);
    cloudFilter.setAttribute("x", "0"); cloudFilter.setAttribute("y", "0");
    cloudFilter.setAttribute("width", "1000"); cloudFilter.setAttribute("height", "1000");
    cloudFilter.setAttribute("filterUnits", "userSpaceOnUse");
    cloudFilter.classList.add('dynamic-def');
    
	cloudFilter.innerHTML = `
        <feTurbulence type="fractalNoise" baseFrequency="0.015" numOctaves="5" result="noise"/>
        <feDisplacementMap in="SourceGraphic" in2="noise" scale="25" result="distorted"/>
        <feGaussianBlur in="distorted" stdDeviation="2" result="blurred"/> 
        <feComponentTransfer in="blurred" result="clouds">
            <feFuncA type="linear" slope="5" intercept="-1.5"/> 
        </feComponentTransfer>
        <feImage href="${lensData}" result="lensMap" width="1000" height="1000"/>
        <feDisplacementMap in="clouds" in2="lensMap" scale="15" xChannelSelector="R" yChannelSelector="G" result="finalClouds"/>
    `;
    dom.defs.appendChild(cloudFilter);

    // Geometry & Layers
    generateGeology(rng, data, structID);
    generateSolidLayers(rng, data, palette, noiseID, structID);
    
    createOrganicZoneMask("mask-liquid", data.latBoil, data.latFreeze, 0, "liquid");
    createOrganicZoneMask("mask-ice", data.latBoil, data.latFreeze, 0, "ice");

    const lMaskId = `mask-liquid-final-${state.seed}`;
    createCompositeMask(lMaskId, "mask-liquid", noiseID, state.waterLevel/100, true, 120);
    
    const oceanGradId = `grad-ocean-${state.seed}`;
    const oGrad = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    oGrad.setAttribute("id", oceanGradId);
    oGrad.setAttribute("cx", "50%"); oGrad.setAttribute("cy", "50%");
    oGrad.classList.add('dynamic-def');
    const baseLiq = data.liquid.color;
    const deepLiq = artColor(baseLiq, -5, 5);
    oGrad.innerHTML = `<stop offset="0%" stop-color="${deepLiq}"/><stop offset="30%" stop-color="${baseLiq}"/>`;
    dom.defs.appendChild(oGrad);

    // LIQUID RECT: 3000px wide for sliding
    const liquidRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    liquidRect.setAttribute("width","3000"); liquidRect.setAttribute("height","1000");
    liquidRect.setAttribute("x", "-1000"); // Center the middle 1000
    liquidRect.setAttribute("fill", `url(#${oceanGradId})`);
    liquidRect.setAttribute("mask", `url(#${lMaskId})`);
    if (data.liquid.type !== "magma") liquidRect.setAttribute("filter", "url(#liquid-blur)");
    dom.gLiquid.appendChild(liquidRect);

    const reflection = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
    reflection.setAttribute("cx","500"); reflection.setAttribute("cy","300");
    reflection.setAttribute("rx","150"); reflection.setAttribute("ry","100");
    reflection.setAttribute("fill", "white"); reflection.setAttribute("opacity", "0.3");
    reflection.setAttribute("transform", "rotate(-45, 500, 300)");
    reflection.setAttribute("filter", "url(#geo-blur)");
    // Reflection stays static relative to light, so we don't put it in the sliding group?
    // Wait, reflections on water should move with the water if it's texturish, but specular highlights stay with the light.
    // The previous code had it in gLiquid which rotates. 
    // For now, let's keep it static on top, or it will look weird sliding.
    // Actually, let's remove it from the sliding group and put it in a static overlay if we want,
    // but the mask slides. 
    // To simplify: I'll attach it to the liquid group but it will slide. 
    // Ideally it should be static. I'll leave it in liquid group for now.
    dom.gLiquid.appendChild(reflection);

    // ICE RECT: 3000px wide
    const iceRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    iceRect.setAttribute("width","3000"); iceRect.setAttribute("height","1000");
    iceRect.setAttribute("x", "-1000");
    iceRect.setAttribute("fill", data.liquid.frozenColor);
    iceRect.setAttribute("mask", `url(#mask-ice)`);
    iceRect.setAttribute("filter", "url(#ice-noise)");
    dom.gIce.appendChild(iceRect);

    if (data.hasLife) {
        const bioZoneMask = "mask-bio-zone";
        createOrganicBandMask(bioZoneMask, data.maxT, data.minT, data.bioMinT, data.bioMaxT, 0);
        const landMaskId = `mask-land-only-${state.seed}`;
        createCompositeMask(landMaskId, null, noiseID, state.waterLevel/255, false); 
        const gBio = document.createElementNS("http://www.w3.org/2000/svg", "g");
        gBio.setAttribute("mask", `url(#${landMaskId})`);
        
        const bioRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        bioRect.setAttribute("width","3000"); bioRect.setAttribute("height","1000");
        bioRect.setAttribute("x", "-1000");
        bioRect.setAttribute("fill", data.bioColor);
        bioRect.setAttribute("mask", `url(#${bioZoneMask})`);
        bioRect.setAttribute("opacity", "0.7");
        bioRect.style.mixBlendMode = "multiply"; 
        gBio.appendChild(bioRect);
        dom.gBio.appendChild(gBio);
    }

    if (state.cloudsEnabled && data.atmosDensity > 0.05) {
        generateClouds(rng, data);
    }
    
    const gradAtmos = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    gradAtmos.setAttribute("id", "grad-atmos");
    gradAtmos.classList.add('dynamic-def');
    gradAtmos.innerHTML = `
        <stop offset="85%" stop-color="${data.cloudHex}" stop-opacity="0" />
        <stop offset="95%" stop-color="${data.cloudHex}" stop-opacity="${data.atmosDensity * 0.4}" />
        <stop offset="100%" stop-color="${data.cloudHex}" stop-opacity="${data.atmosDensity}" />
    `;
    dom.defs.appendChild(gradAtmos);
    dom.rimLight.setAttribute('stroke', artColor(data.cloudHex, 20, -10, 0));

    if (data.rings) generateRings(rng, data);

    softUpdate();
}

function createOrganicZoneMask(id, latBoil, latFreeze, tilt, type) {
    const gradId = `grad-${id}-${state.seed}`;
    const grad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    grad.setAttribute("id", gradId);
    grad.setAttribute("x1", "0"); grad.setAttribute("y1", "0"); grad.setAttribute("x2", "0"); grad.setAttribute("y2", "1");
    // Zone masks are vertical gradients. Since they apply to the sliding rects, they need to cover the 3000px width.
    // But gradientUnits defaults to objectBoundingBox. 
    // If the rect is 3000 wide, the gradient stretches. 
    // We want the gradient to be vertical (temperature bands), which is uniform across X.
    // So objectBoundingBox is fine for X.
    grad.setAttribute("gradientTransform", `rotate(${tilt}, 0.5, 0.5)`);
    grad.classList.add('dynamic-def');

    let stops = "";
    const boilY_top = 0.5 - (latBoil * 0.5); 
    const frzY_top  = 0.5 - (latFreeze * 0.5);
    const boilY_bot = 0.5 + (latBoil * 0.5);
    const frzY_bot  = 0.5 + (latFreeze * 0.5);
    const spread = 0.02;

	if (type === "liquid") {
        stops = `<stop offset="0%" stop-color="white"/><stop offset="${(boilY_top-spread)*100}%" stop-color="white"/><stop offset="${(boilY_top+spread)*100}%" stop-color="#c0c0c0"/><stop offset="${(boilY_bot-spread)*100}%" stop-color="#c0c0c0"/><stop offset="${(boilY_bot+spread)*100}%" stop-color="white"/><stop offset="100%" stop-color="white"/>`;
    } else if (type === "ice") {
        stops = `<stop offset="0%" stop-color="white"/><stop offset="${(frzY_top-spread)*100}%" stop-color="white"/><stop offset="${(frzY_top+spread)*100}%" stop-color="#c0c0c0"/><stop offset="${(frzY_bot-spread)*100}%" stop-color="#c0c0c0"/><stop offset="${(frzY_bot+spread)*100}%" stop-color="white"/><stop offset="100%" stop-color="white"/>`;
    }
    grad.innerHTML = stops;
    dom.defs.appendChild(grad);
    const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
    mask.setAttribute("id", id);
    mask.classList.add('dynamic-def');
    
    // Mask Rect needs to match the sliding rect dimensions: 3000x1000
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("width", "3000"); rect.setAttribute("height", "1000");
    rect.setAttribute("x", "-1000");
    rect.setAttribute("fill", `url(#${gradId})`);
    rect.setAttribute("filter", "url(#zone-warp)");
    mask.appendChild(rect);
    dom.defs.appendChild(mask);
}

function createOrganicBandMask(id, maxT, minT, targetMin, targetMax, tilt) {
    const getLat = (t) => (maxT - t) / (maxT - minT);
    let lat1 = Math.max(0, Math.min(1, getLat(targetMax))); 
    let lat2 = Math.max(0, Math.min(1, getLat(targetMin))); 
    const y1_top = 0.5 - lat1 * 0.5; const y2_top = 0.5 - lat2 * 0.5;
    const y1_bot = 0.5 + lat1 * 0.5; const y2_bot = 0.5 + lat2 * 0.5;
    const gradId = `grad-${id}-${state.seed}`;
    const grad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    grad.setAttribute("id", gradId);
    grad.setAttribute("x1", "0"); grad.setAttribute("y1", "0"); grad.setAttribute("y2", "1");
    grad.setAttribute("gradientTransform", `rotate(${tilt}, 0.5, 0.5)`);
    grad.classList.add('dynamic-def');
    const spread = 0.05; 
    grad.innerHTML = `<stop offset="0%" stop-color="#c0c0c0"/><stop offset="${(y2_top-spread)*100}%" stop-color="#c0c0c0"/><stop offset="${(y2_top+spread)*100}%" stop-color="white"/><stop offset="${(y1_top-spread)*100}%" stop-color="white"/><stop offset="${(y1_top+spread)*100}%" stop-color="#c0c0c0"/><stop offset="${(y1_bot-spread)*100}%" stop-color="#c0c0c0"/><stop offset="${(y1_bot+spread)*100}%" stop-color="white"/><stop offset="${(y2_bot-spread)*100}%" stop-color="white"/><stop offset="${(y2_bot+spread)*100}%" stop-color="#c0c0c0"/><stop offset="100%" stop-color="#c0c0c0"/>`;
    dom.defs.appendChild(grad);
    const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
    mask.setAttribute("id", id);
    mask.classList.add('dynamic-def');
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("width", "3000"); rect.setAttribute("height", "1000");
    rect.setAttribute("x", "-1000");
    rect.setAttribute("fill", `url(#${gradId})`);
    rect.setAttribute("filter", "url(#zone-warp)");
    mask.appendChild(rect);
    dom.defs.appendChild(mask);
}

function createCompositeMask(id, thermalMaskId, noiseId, threshold, invert, slopeVal = 50) {
    const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
    mask.setAttribute("id", id);
    mask.classList.add('dynamic-def');
    const threshId = `thresh-${id}`;
    const filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    filter.setAttribute("id", threshId);
    filter.classList.add('dynamic-def');
    let slope = slopeVal, intercept = -(threshold * slope) + 0.5;
    if (invert) { slope = -slopeVal; intercept = (threshold * slopeVal) + 0.5; }
    filter.innerHTML = `<feComponentTransfer><feFuncR type="linear" slope="${slope}" intercept="${intercept}" /><feFuncG type="linear" slope="${slope}" intercept="${intercept}" /><feFuncB type="linear" slope="${slope}" intercept="${intercept}" /></feComponentTransfer>`;
    dom.defs.appendChild(filter);
    
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const r1 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    // 3000px wide for sliding
    r1.setAttribute("width","3000"); r1.setAttribute("height","1000");
    r1.setAttribute("x", "-1000");
    r1.setAttribute("filter", `url(#${noiseId}) url(#${threshId})`);
    g.appendChild(r1);
    if (thermalMaskId) { r1.setAttribute("mask", `url(#${thermalMaskId})`); }
    mask.appendChild(g);
    dom.defs.appendChild(mask);
}

function generateSolidLayers(rng, data, palette, noiseID, structID) {
    state.layerThresholds = []; 
    let stops = [0], current = 0, gapBase = 0.05;
    if (data.solid.type === 'crystal') gapBase = 0.03;
    if (data.solid.roughness < 0.6) gapBase = 0.08;
    const multiplier = 1.08; 
    for(let i=1; i<palette.length; i++) { current += gapBase; stops.push(current); gapBase *= multiplier; }
    const maxVal = stops[stops.length-1];
    const normalizedStops = stops.map(v => 0.08 + (v / maxVal) * 0.75);

    palette.forEach((color, i) => {
        const maskID = `mask-layer-${i}-${state.seed}`;
        const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
        mask.setAttribute("id", maskID);
        mask.classList.add('dynamic-def');
        const gMask = document.createElementNS("http://www.w3.org/2000/svg", "g");
        
        // 3000px wide Rect
        const rectNoise = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rectNoise.setAttribute("width", "3000"); rectNoise.setAttribute("height", "1000");
        rectNoise.setAttribute("x", "-1000");
        rectNoise.setAttribute("filter", `url(#${noiseID})`); 
        gMask.appendChild(rectNoise);

        const threshID = `thresh-layer-${i}`;
        const threshFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
        threshFilter.setAttribute("id", threshID);
        threshFilter.classList.add('dynamic-def');
        const jitter = (rng() * 0.04) - 0.02;
        const level = Math.max(0, Math.min(1, normalizedStops[i] + jitter));
        state.layerThresholds.push(level); 
        const slope = 60, intercept = -(level * slope);
        threshFilter.innerHTML = `<feComponentTransfer><feFuncR type="linear" slope="${slope}" intercept="${intercept}" /><feFuncG type="linear" slope="${slope}" intercept="${intercept}" /><feFuncB type="linear" slope="${slope}" intercept="${intercept}" /></feComponentTransfer>`;
        dom.defs.appendChild(threshFilter);
        gMask.setAttribute("filter", `url(#${threshID})`);
        mask.appendChild(gMask);
        dom.defs.appendChild(mask);
        
        // Layer Rect 3000px
        const layerRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        layerRect.setAttribute("width", "3000"); layerRect.setAttribute("height", "1000");
        layerRect.setAttribute("x", "-1000");
        layerRect.setAttribute("fill", color);
        layerRect.setAttribute("mask", `url(#${maskID})`);
        dom.gTerrain.appendChild(layerRect);
    });
}

function generateGeology(rng, data, id) {
    dom.gGeoStructure.innerHTML = ''; // Clear
    const singleTile = document.createElementNS("http://www.w3.org/2000/svg", "g");

    if (data.roughness > 0.5) {
        const count = Math.ceil(8 * data.roughness);
        for (let i = 0; i < count; i++) {
            const lat1 = rng()*2-1; const lon1 = rng()*6.28;
            const lat2 = rng()*2-1; const lon2 = lon1 + rng();
            let d = "";
            for(let t=0; t<=12; t++) {
                const step = t/12;
                const lat = lat1+(lat2-lat1)*step;
                const lon = lon1+(lon2-lon1)*step;
                const p = projectSphere(450, lat, lon, 0); 
                if(p.z > -100) d += (t===0?"M":"L") + ` ${p.x} ${p.y}`;
            }
            if(d) {
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", d);
                path.setAttribute("fill", "none");
                path.setAttribute("stroke", "white");
                path.setAttribute("stroke-width", rng() * 30 + 10);
                path.setAttribute("filter", "url(#geo-blur)");
                path.setAttribute("opacity", 0.6 * data.roughness);
                singleTile.appendChild(path);
            }
        }
    }

    // Infinite wrapper with clones (-1000, 0, 1000)
    // Since we are now moving the PARENT group via transform, we just place the clones.
    const tileLeft = singleTile.cloneNode(true); tileLeft.setAttribute("transform", "translate(-1000,0)");
    const tileRight = singleTile.cloneNode(true); tileRight.setAttribute("transform", "translate(1000,0)");
    
    const wrapper = document.createElementNS("http://www.w3.org/2000/svg", "g");
    wrapper.appendChild(tileLeft);
    wrapper.appendChild(singleTile);
    wrapper.appendChild(tileRight);
    
    // We do NOT apply the lens here anymore because it's applied to the common container
    dom.gGeoStructure.appendChild(wrapper);
}

function generateClouds(rng, data) {
    if (!state.cloudsEnabled || data.atmosDensity < 0.1) {
        dom.gCloudsRotator.innerHTML = '';
        return;
    }

    const R = 640; 
    const generateCloudSpine = (yBase, width, xOffset) => {
        const points = [];
        const steps = 60;
        const startX = -width / 2 + xOffset;
        const stepSize = width / steps;
        let yDrift = 0;
        for (let i = 0; i <= steps; i++) {
            const xRel = startX + (i * stepSize);
            const xRatio = xRel / R;
            const sphereCurve = (xRatio * xRatio) * yBase * -0.8; 
            let y = yBase + sphereCurve;
            yDrift += (rng() - 0.5) * 1.0;
            yDrift *= 0.95;
            y += yDrift;
            points.push({ x: 500 + xRel, y: 500 + y });
        }
        return points;
    };

    const generateCloudShapeFromSpine = (spinePoints, options = {}) => {
        const { baseThickness=30, thicknessVariance=10, edgeNoise=10, taperPower=0.5 } = options;
        if (spinePoints.length < 3) return "";
        const topPoints = [], botPoints = [];
        let thickness = baseThickness;
        for (let i = 0; i < spinePoints.length; i++) {
            const p_curr = spinePoints[i];
            const p_next = spinePoints[Math.min(spinePoints.length-1, i+1)];
            const p_prev = spinePoints[Math.max(0, i-1)];
            const dx = p_next.x - p_prev.x, dy = p_next.y - p_prev.y;
            let nx = -dy, ny = dx;
            const len = Math.sqrt(nx*nx+ny*ny);
            if (len > 0) { nx /= len; ny /= len; }
            const progress = i / (spinePoints.length - 1);
            const taper = Math.sin(progress * Math.PI); 
            const thickMod = Math.pow(taper, taperPower);
            thickness += (rng() - 0.5) * (thicknessVariance / 5);
            thickness = Math.max(5, thickness); 
            const currentThick = thickness * thickMod;
            const jag = (rng() - 0.5) * edgeNoise * thickMod;
            topPoints.push({ x: p_curr.x + nx * (currentThick * 0.5 + jag), y: p_curr.y + ny * (currentThick * 0.5 + jag) });
            botPoints.push({ x: p_curr.x - nx * (currentThick * 0.5 + jag), y: p_curr.y - ny * (currentThick * 0.5 + jag) });
        }
        let d = `M ${topPoints[0].x.toFixed(1)} ${topPoints[0].y.toFixed(1)}`;
        for (let i = 1; i < topPoints.length; i++) d += ` L ${topPoints[i].x.toFixed(1)} ${topPoints[i].y.toFixed(1)}`;
        for (let i = botPoints.length - 1; i >= 0; i--) d += ` L ${botPoints[i].x.toFixed(1)} ${botPoints[i].y.toFixed(1)}`;
        d += " Z";
        return d;
    };

    const generateCloudSystem = (driverSpine, baseColor, yBase) => {
        const systemElements = [];
        const stackingDirection = yBase < 0 ? -1 : 1; 
        const createStack = (spine, layers, scale) => {
            const elements = [];
            for (let i = 0; i <= layers; i++) {
                const lengthRatio = 1.0 - (i * 0.08); 
                const subLength = Math.floor(spine.length * Math.max(0.4, lengthRatio));
                const slack = spine.length - subLength;
                const startIdx = Math.floor(rng() * (slack * 0.8) + (slack * 0.1));
                const baseSubSpine = spine.slice(startIdx, startIdx + subLength);
                const offsetDist = i * 14 * scale * stackingDirection; 
                const disjointX = (rng() - 0.5) * 20 * scale; 
                const offsetSubSpine = baseSubSpine.map((p, j, arr) => {
                    const p_next = arr[Math.min(arr.length-1, j+1)];
                    const p_prev = arr[Math.max(0, j-1)];
                    const dx = p_next.x - p_prev.x, dy = p_next.y - p_prev.y;
                    let nx = -dy, ny = dx;
                    const len = Math.sqrt(nx*nx+ny*ny);
                    if (len > 0) { nx /= len; ny /= len; }
                    return { x: p.x + (nx * offsetDist) + disjointX, y: p.y + (ny * offsetDist) };
                });
                const subPathData = generateCloudShapeFromSpine(offsetSubSpine, {
                    baseThickness: (35 - (i * 2)) * scale, edgeNoise: (12 + i) * scale, taperPower: 0.5
                });
                if (subPathData) {
                    const el = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    const lightShift = 40 - (i * 10); 
                    const subColor = artColor(baseColor, lightShift, -5);
                    el.setAttribute("d", subPathData);
                    el.setAttribute("fill", subColor);
                    el.setAttribute("fill-opacity", 0.6); 
                    elements.push(el);
                }
            }
            return elements;
        };
        const mainLayers = Math.floor(rng() * 4) + 4; 
        systemElements.push(...createStack(driverSpine, mainLayers, 1.0));
        return systemElements;
    };

    dom.gCloudsRotator.innerHTML = '';
    const singleTile = document.createElementNS("http://www.w3.org/2000/svg", "g");

    const clusterCount = Math.floor(rng() * 2) + 3;
    const range = 1.85; 
    const zoneSize = range / clusterCount;
    
    for (let i = 0; i < clusterCount; i++) {
        const zoneTop = -(range/2) + (i * zoneSize);
        const latPos = zoneTop + (rng() * zoneSize * 0.8) + (zoneSize * 0.1);
        const yBase = latPos * R;
        const maxChord = Math.sqrt(Math.max(0, R*R - yBase*yBase)) * 2;
        const width = maxChord * (0.2 + rng() * 0.7);
        const maxOffset = (maxChord - width) / 2;
        const xOffset = (rng() * maxOffset * 2) - maxOffset;
        const dist = Math.abs(latPos);
        const col = artColor(data.cloudHex, dist * -15, dist * -5);
        const spine = generateCloudSpine(yBase, width, xOffset);
        const els = generateCloudSystem(spine, col, yBase);
        els.forEach(el => singleTile.appendChild(el));
    }

    const wrapper = document.createElementNS("http://www.w3.org/2000/svg", "g");
    wrapper.setAttribute("id", "cloud-wrapper");
    // Clouds use their own filter
    wrapper.setAttribute("filter", `url(#cloud-atmos-${state.seed})`);
    wrapper.setAttribute("opacity", "0.6");
    
    const tileLeft = singleTile.cloneNode(true); tileLeft.setAttribute("transform", "translate(-1000,0)");
    const tileRight = singleTile.cloneNode(true); tileRight.setAttribute("transform", "translate(1000,0)");
    
    wrapper.appendChild(tileLeft);
    wrapper.appendChild(singleTile);
    wrapper.appendChild(tileRight);
    
    dom.gCloudsRotator.appendChild(wrapper);
}

function generateRings(rng, data) {
    dom.gRingsBack.innerHTML = '';
    dom.gRingsFront.innerHTML = '';
    const tilt = data.tilt; 
    if (rng() > 0.2) {
        const ringBase = data.solid.color;
        for(let i=0; i<8; i++) {
            const r = 600 + i * 20; const ry = r * 0.25;
            const arc = (s,e) => {
                const rad=Math.PI/180;
                const sx=500+r*Math.cos(e*rad), sy=500+ry*Math.sin(e*rad);
                const ex=500+r*Math.cos(s*rad), ey=500+ry*Math.sin(s*rad);
                return `M ${sx} ${sy} A ${r} ${ry} 0 0 0 ${ex} ${ey}`;
            };
            const width = rng()*8+2; const opacity = rng() * 0.3 + 0.1;
            const color = artColor(ringBase, (i%2===0?20:-20), -10, 0);
            const back = document.createElementNS("http://www.w3.org/2000/svg", "path");
            back.setAttribute("d", arc(180, 360));
            back.setAttribute("stroke", color); back.setAttribute("fill", "none");
            back.setAttribute("stroke-width", width); back.setAttribute("opacity", opacity);
            back.setAttribute("transform", `rotate(${tilt}, 500, 500)`);
            dom.gRingsBack.appendChild(back);
            const front = back.cloneNode();
            front.setAttribute("d", arc(0, 180));
            dom.gRingsFront.appendChild(front);
        }
        return;
    }
    const solidColor = data.solid.color; const iceColor = data.liquid.frozenColor || "#e0f2fe";
    const palette = [solidColor, iceColor, artColor(solidColor, 15, -10), artColor(iceColor, -15, 5)];
    const perspective = 0.25 + rng() * 0.15; 
    const bands = [
        { name: "B-Ring", start: 540, end: 650, density: 0.8, particles: 200 },
        { name: "A-Ring", start: 670, end: 800, density: 0.5, particles: 200 },
        { name: "F-Ring", start: 810, end: 825, density: 0.3, particles: 30 }
    ];
    const createArcPath = (radius, ry, startAngle, endAngle) => {
        const rad = Math.PI / 180;
        const sx = 500 + radius * Math.cos(endAngle * rad); const sy = 500 + ry * Math.sin(endAngle * rad);
        const ex = 500 + radius * Math.cos(startAngle * rad); const ey = 500 + ry * Math.sin(startAngle * rad);
        return `M ${sx} ${sy} A ${radius} ${ry} 0 0 0 ${ex} ${ey}`;
    };
    bands.forEach(band => {
        for (let i = 0; i < band.particles; i++) {
            const progress = rng();
            const radius = band.start + progress * (band.end - band.start);
            const ry = radius * perspective;
            const wave = Math.sin(progress * Math.PI * (10 + rng() * 10));
            const finalOpacity = (band.density * 0.3) * (0.5 + rng() * 0.5) + wave * 0.1;
            if (finalOpacity < 0.04) continue;
            const color = palette[Math.floor(rng() * palette.length)];
            const width = 1 + rng() * 3.5;
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("stroke", color); path.setAttribute("fill", "none");
            path.setAttribute("stroke-width", width); path.setAttribute("stroke-opacity", finalOpacity);
            path.setAttribute("transform", `rotate(${tilt}, 500, 500)`);
            const backPath = path.cloneNode(); backPath.setAttribute("d", createArcPath(radius, ry, 180, 360));
            dom.gRingsBack.appendChild(backPath);
            const frontPath = path.cloneNode(); frontPath.setAttribute("d", createArcPath(radius, ry, 0, 180));
            dom.gRingsFront.appendChild(frontPath);
        }
    });
}

function projectSphere(r, lat, lon, tilt) {
    let x = r * Math.cos(lat) * Math.sin(lon);
    let y = r * Math.sin(lat);
    let z = r * Math.cos(lat) * Math.cos(lon);
    let rad = tilt * (Math.PI/180);
    let xT = x * Math.cos(rad) - y * Math.sin(rad);
    let yT = x * Math.sin(rad) + y * Math.cos(rad);
    return { x: xT + 500, y: -yT + 500, z: z };
}

function softUpdate() {
    const shadowOp = state.shadow / 100;
    dom.terminator.setAttribute('opacity', shadowOp);
    dom.terminator.setAttribute('d', 'M 500,50 A 450,450 0 1,1 500,950 A 550,450 0 1,0 500,50');
    
    const old = dom.defs.querySelector('#shadow-grad');
    if(old) old.remove();
    const grad = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    grad.setAttribute("id", "shadow-grad");
    grad.setAttribute("cx", "35%"); grad.setAttribute("cy", "35%");
    grad.innerHTML = `<stop offset="50%" stop-color="#050508" stop-opacity="0"/><stop offset="100%" stop-color="#050508" stop-opacity="${shadowOp}"/>`;
    dom.defs.appendChild(grad);

    dom.gCloudsRotator.style.display = (state.cloudsEnabled) ? 'block' : 'none';

    const waterFactor = state.waterLevel / 100;
    const updateFilterIntercept = (id, val) => {
        const filter = document.getElementById(id);
        if(!filter) return;
        const funcs = filter.querySelectorAll('feFuncR, feFuncG, feFuncB');
        funcs.forEach(f => f.setAttribute('intercept', val));
    };
    if (state.layerThresholds && state.layerThresholds.length) {
        state.layerThresholds.forEach((baseLevel, i) => {
            const offset = (waterFactor - 0.5) * 1.5; 
            const target = baseLevel + offset;
            updateFilterIntercept(`thresh-layer-${i}`, -(target * 60));
        });
    }
    const slope = 120;
    const lMaskThreshId = `thresh-mask-liquid-final-${state.seed}`;
    updateFilterIntercept(lMaskThreshId, (waterFactor * slope) + 0.5);
    const landMaskThreshId = `thresh-mask-land-only-${state.seed}`;
    updateFilterIntercept(landMaskThreshId, -(waterFactor * 50) + 0.5);

    // --- SEAMLESS ROTATION UPDATE (High Performance) ---
    const rot = state.rotation;
    
    // Calculate sliding offset. 360deg = 1000px translation.
    // Modulo 1000 ensures infinite scroll illusion.
    const translate = -((rot / 360) * 1000) % 1000;
    
    // Move the surface group via CSS Transform (GPU accelerated)
    if (dom.gSurfaceSlider) {
        dom.gSurfaceSlider.setAttribute("transform", `translate(${translate}, 0)`);
    }

    // Move Clouds
    const cloudWrap = document.getElementById('cloud-wrapper');
    if (cloudWrap) {
        // Cloud parallax or just sync? Sync for now.
        cloudWrap.setAttribute("transform", `translate(${translate}, 0)`);
    }
}

window.onload = () => {
    const bg = document.getElementById('starfield');
    for(let i=0; i<80; i++) {
        const s = document.createElement('div');
        s.className = 'star';
        s.style.top = Math.random()*100+'%'; s.style.left = Math.random()*100+'%';
        s.style.width = Math.random()*2+'px'; s.style.height = s.style.width;
        s.style.animationDelay = Math.random()*5+'s';
        bg.appendChild(s);
    }

    const triggerRebuild = () => {
        state.seed = dom.seedInput.value.toUpperCase();
        state.waterLevel = parseInt(dom.rngWater.value);
        state.rotation = parseInt(dom.rngRotation.value);
        state.shadow = parseInt(dom.rngShadow.value);
        state.cloudsEnabled = dom.chkClouds.checked;
        fullRebuild();
    }

    const handleManualUpdate = () => {
        state.waterLevel = parseInt(dom.rngWater.value);
        state.shadow = parseInt(dom.rngShadow.value);
        state.cloudsEnabled = dom.chkClouds.checked;
        dom.lblWater.innerText = state.waterLevel + '%';
        dom.lblShadow.innerText = state.shadow + '%';
        softUpdate();
    };

    const handleRotation = () => {
        state.rotation = parseInt(dom.rngRotation.value);
        dom.lblRotation.innerText = state.rotation + 'Â°';
        softUpdate();
    }

    dom.btnRnd.addEventListener('click', () => {
        const pfx = ["TERRA", "AQUA", "MAGMA", "CRYO", "XENO", "LUNA", "SOL", "VEGA", "NOVA", "ATLAS", "ION", "KRYPTON"];
        dom.seedInput.value = `${pfx[Math.floor(Math.random()*pfx.length)]}-${Math.floor(Math.random()*9999)}`;
        const tmpRng = createRNG(dom.seedInput.value);
        const tmpData = generatePlanetData(tmpRng);
        dom.rngWater.value = tmpData.suggestedWater;
        dom.lblWater.innerText = tmpData.suggestedWater + '%';
        triggerRebuild();
    });

    dom.btnGen.addEventListener('click', triggerRebuild);
    dom.seedInput.addEventListener('change', triggerRebuild);
    dom.rngWater.addEventListener('input', handleManualUpdate);
    dom.rngShadow.addEventListener('input', () => { state.shadow = parseInt(dom.rngShadow.value); softUpdate(); });
    dom.chkClouds.addEventListener('change', () => { state.cloudsEnabled = dom.chkClouds.checked; softUpdate(); });
    dom.rngRotation.addEventListener('input', handleRotation);

    dom.btnDownload.addEventListener('click', () => {
        const svgData = dom.svg.outerHTML;
        const blob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `FORGE_V10.2_${state.seed}.svg`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });

    const initRng = createRNG(dom.seedInput.value);
    const initData = generatePlanetData(initRng);
    dom.rngWater.value = initData.suggestedWater;
    dom.lblWater.innerText = initData.suggestedWater + '%';
    triggerRebuild();
};
</script>
</body>
</html>
