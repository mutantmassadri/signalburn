<!-- --- START OF FILE Paste February 02, 2026 - 4:03PM --- -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SB PLANETGEN V10.3 - OPTIMIZED</title>
    <style>
        /* --- CORE VISUALS (UNCHANGED) --- */
        :root {
            --c-bg: #050507; --c-panel: #141416; --c-border: #27272a;
            --c-accent: #3b82f6; --c-accent-glow: rgba(59, 130, 246, 0.5);
            --c-text: #e4e4e7; --c-text-dim: #a1a1aa;
            --f-mono: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
            --f-sans: system-ui, -apple-system, sans-serif;
        }
        * { box-sizing: border-box; outline: none; }
        body {
            background-color: var(--c-bg); color: var(--c-text);
            font-family: var(--f-sans); margin: 0; height: 100vh;
            display: grid; grid-template-columns: 1fr 380px; overflow: hidden;
        }
        .stage {
            position: relative; background: radial-gradient(circle at 50% 50%, #1a1a20 0%, #000 90%);
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }
        .stars { position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 0; pointer-events: none; }
        .star {
            position: absolute; background: white; border-radius: 50%; opacity: 0;
            animation: flicker 4s infinite ease-in-out;
        }
        @keyframes flicker { 0% { opacity: 0.1; transform: scale(0.5); } 50% { opacity: 0.8; transform: scale(1); } 100% { opacity: 0.1; transform: scale(0.5); } }
        #render-target {
            width: 95vmin; height: 95vmin; z-index: 10;
            filter: drop-shadow(0 0 50px rgba(0,0,0,0.8)); will-change: transform; 
        }
        .deck {
            background: var(--c-panel); border-left: 1px solid var(--c-border);
            padding: 0; display: flex; flex-direction: column; overflow-y: auto;
            box-shadow: -10px 0 40px rgba(0,0,0,0.5); z-index: 20;
        }
        .deck-header { padding: 20px; border-bottom: 1px solid var(--c-border); background: rgba(0,0,0,0.2); }
        h1 {
            font-family: var(--f-mono); font-size: 1.1rem; margin: 0 0 10px 0;
            text-transform: uppercase; letter-spacing: 2px; color: var(--c-accent);
            text-shadow: 0 0 15px var(--c-accent-glow); display: flex; justify-content: space-between;
        }
        .version { font-size: 0.7em; opacity: 0.5; color: white; }
        .seed-row { display: flex; gap: 8px; }
        input[type="text"] {
            background: var(--c-bg); border: 1px solid var(--c-border); color: var(--c-text);
            font-family: var(--f-mono); padding: 12px; border-radius: 6px; flex: 1;
            font-size: 0.9rem; transition: border 0.2s;
        }
        input[type="text"]:focus { border-color: var(--c-accent); }
        .btn-icon {
            width: 44px; background: var(--c-bg); border: 1px solid var(--c-border);
            color: var(--c-text); border-radius: 6px; cursor: pointer; font-size: 1.2rem;
            transition: all 0.2s;
        }
        .btn-icon:hover { background: var(--c-border); color: #fff; }
        .controls { padding: 20px; display: flex; flex-direction: column; gap: 20px; }
        .section-title {
            font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1.5px;
            color: var(--c-text-dim); font-weight: 700; margin-bottom: 12px;
            display: flex; align-items: center; gap: 8px;
        }
        .section-title::after { content: ''; flex: 1; height: 1px; background: var(--c-border); }
        .btn-action {
            width: 100%; padding: 16px;
            background: linear-gradient(135deg, var(--c-accent) 0%, #2563eb 100%);
            border: none; color: white; font-weight: bold; text-transform: uppercase;
            letter-spacing: 1px; border-radius: 8px; cursor: pointer;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3); transition: transform 0.1s;
        }
        .btn-action:active { transform: scale(0.98); }
        .btn-action:disabled { opacity: 0.5; cursor: wait; filter: saturate(0); }
        .data-panel {
            background: #0f0f11; border: 1px solid var(--c-border);
            border-radius: 6px; padding: 12px; font-family: var(--f-mono); font-size: 0.75rem;
            display: grid; gap: 8px;
        }
        .data-row { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px dashed #27272a; padding-bottom: 4px; }
        .data-row:last-child { border-bottom: none; }
        .data-lbl { color: var(--c-text-dim); }
        .data-val { color: var(--c-text); font-weight: bold; text-align: right;}
        .tag { font-size: 0.7em; padding: 2px 4px; border-radius: 3px; margin-left: 5px; opacity: 0.9; }
        .tag-c { background: #064e3b; color: #6ee7b7; border: 1px solid #059669; }
        .tag-si { background: #312e81; color: #a5b4fc; border: 1px solid #4f46e5; }
        .tag-fe { background: #451a03; color: #fdba74; border: 1px solid #c2410c; }
        .tag-x { background: #4c1d95; color: #e9d5ff; border: 1px solid #8b5cf6; }
        .tag-bio { background: #831843; color: #f9a8d4; border: 1px solid #db2777; }
        .tag-none { background: #27272a; color: #a1a1aa; border: 1px solid #3f3f46; }
        .tag-life { color: #10b981; text-shadow: 0 0 10px rgba(16,185,129,0.3); font-weight: bold; }
        .tag-dead { color: var(--c-text-dim); opacity: 0.5; }
        .slider-group { margin-bottom: 12px; }
        .slider-header {
            display: flex; justify-content: space-between; font-size: 0.8rem;
            margin-bottom: 6px; color: var(--c-text-dim);
        }
        input[type="range"] {
            -webkit-appearance: none; width: 100%; height: 6px;
            background: #27272a; border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%;
            background: var(--c-text); cursor: pointer; border: 2px solid var(--c-bg);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .toggle-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 0; font-size: 0.9rem;
        }
        .switch { position: relative; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-switch {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #27272a; border-radius: 24px; transition: .3s;
        }
        .slider-switch:before {
            position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px;
            background-color: #a1a1aa; border-radius: 50%; transition: .3s;
        }
        input:checked + .slider-switch { background-color: var(--c-accent); }
        input:checked + .slider-switch:before { transform: translateX(20px); background-color: white; }
        .dl-group { margin-top: auto; padding: 24px; border-top: 1px solid var(--c-border); }
        .btn-dl {
            width: 100%; padding: 12px; background: transparent; border: 1px solid var(--c-border);
            color: var(--c-text); border-radius: 6px; cursor: pointer; font-family: var(--f-mono);
            font-size: 0.8rem; display: flex; align-items: center; justify-content: center; gap: 10px;
        }
        .btn-dl:hover { background: #27272a; }
        @media (max-width: 800px) {
            body { grid-template-columns: 1fr; grid-template-rows: minmax(0, 1fr) auto; height: 100vh; }
            .deck { border-left: none; border-top: 1px solid var(--c-border); box-shadow: 0 -10px 40px rgba(0,0,0,0.5); max-height: 45vh; }
            #render-target { width: 90vmin; height: 90vmin; }
            .dl-group { margin-top: 12px; padding-top: 12px; padding-bottom: 12px; }
        }
    </style>
</head>
<body>

    <div class="stage" id="stage">
        <div class="stars" id="starfield"></div>
        <svg id="render-target" viewBox="-200 -200 1400 1400" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <clipPath id="planet-clip"><circle cx="500" cy="500" r="450" /></clipPath>
                <filter id="geo-blur" x="-20%" y="-20%" width="140%" height="140%"><feGaussianBlur stdDeviation="25" /></filter>
                <filter id="liquid-blur" x="-20%" y="-20%" width="140%" height="140%"><feGaussianBlur stdDeviation="1" /></filter>
                <filter id="zone-warp" x="-20%" y="-20%" width="140%" height="140%">
                     <feTurbulence type="fractalNoise" baseFrequency="0.015" numOctaves="4" seed="123" result="turb"/>
                     <feDisplacementMap in="SourceGraphic" in2="turb" scale="60" xChannelSelector="R" yChannelSelector="G"/>
                     <feGaussianBlur stdDeviation="10" />
                </filter>
                <filter id="blur-shadow"><feGaussianBlur stdDeviation="20" /></filter>
            </defs>
            <g id="layer-rings-back"></g>
            <circle id="planet-halo" cx="500" cy="500" r="453" fill="#111115" />
            <g id="planet-sphere" clip-path="url(#planet-clip)">
                <g id="planet-axis-group">
                    <g id="planet-lens-container">
                        <g id="planet-surface-slider">
                            <g id="group-terrain"></g>
                            <g id="group-liquid"></g>
                            <g id="group-ice" style="mix-blend-mode: normal;"></g>
                            <g id="group-bio"></g>
                            <g id="geo-structure-layer"></g>
                        </g>
                    </g>
                    <g id="layer-clouds-rotator"></g>
                </g>
            </g>
            <circle id="atmos-glow" cx="500" cy="500" r="450" fill="url(#grad-atmos)" pointer-events="none" style="mix-blend-mode: screen;"/>
            <circle id="rim-light" cx="500" cy="500" r="448" fill="none" stroke="#fff" stroke-width="3" opacity="0.4" pointer-events="none"/>
            <circle id="shadow-overlay" cx="500" cy="500" r="450" fill="url(#shadow-grad)" pointer-events="none"/>
            <path id="terminator" d="" fill="#08080a" opacity="0.6" filter="url(#blur-shadow)" style="mix-blend-mode: multiply;" pointer-events="none"/>
            <g id="layer-rings-front"></g>
        </svg>
    </div>

    <div class="deck">
        <div class="deck-header">
            <h1>SB PLANETGEN <span class="version">V10.3 OPT</span></h1>
            <div class="seed-row">
                <input type="text" id="seed-input" value="AQUA-VITA">
                <button class="btn-icon" id="btn-rnd" title="Randomize">ðŸŽ²</button>
            </div>
        </div>

        <div class="controls">
            <div class="data-panel" id="data-panel">
                <div class="data-row"><span class="data-lbl">Temperature:</span> <span class="data-val" id="val-temp">--</span></div>
                <div class="data-row"><span class="data-lbl">Surface:</span> <span class="data-val" id="val-solid">--</span></div>
                <div class="data-row"><span class="data-lbl">Fluid:</span> <span class="data-val" id="val-liquid">--</span></div>
                <div class="data-row"><span class="data-lbl">Atmosphere:</span> <span class="data-val" id="val-atmos">--</span></div>
                <div class="data-row"><span class="data-lbl">Biology:</span> <span class="data-val tag-dead" id="val-life">NONE DETECTED</span></div>
            </div>
            <div>
                <div class="section-title">Manual Override</div>
                <div class="slider-group">
                    <div class="slider-header"><span>Sea Level</span><span id="lbl-water">50%</span></div>
                    <input type="range" id="rng-water" min="0" max="100" value="50">
                </div>
                <div class="slider-group">
                    <div class="slider-header"><span>Planet Rotation</span><span id="lbl-rotation">0Â°</span></div>
                    <input type="range" id="rng-rotation" min="0" max="360" value="0">
                </div>
                <div class="toggle-row">
                    <span>Show Clouds</span>
                    <label class="switch"><input type="checkbox" id="chk-clouds" checked><span class="slider-switch"></span></label>
                </div>
            </div>
            <div>
                <div class="section-title">Lighting</div>
                <div class="slider-group">
                    <div class="slider-header"><span>Shadow Intensity</span><span id="lbl-shadow">50%</span></div>
                    <input type="range" id="rng-shadow" min="0" max="95" value="50">
                </div>
            </div>
            <button class="btn-action" id="btn-gen">Update View</button>
        </div>
        <div class="dl-group">
            <button class="btn-dl" id="btn-download">
                <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg>
                Download Vector SVG
            </button>
        </div>
    </div>

<script>
/**
 * SB PLANETGEN V10.3 OPTIMIZED - LIGHTWEIGHT CORE
 * Optimized for speed and iPhone/WebKit stability.
 * Changes:
 * - Render resolution halved (1500x500) with compensated noise frequencies.
 * - Shared Canvas Singleton (reduces GC overhead).
 * - Ring Particle Batching (drastic DOM reduction).
 * - Cloud geometry simplification.
 */

const LIQUIDS = [
    { name: "Water",       color: "#3b82f6", freeze: 0,    boil: 100,  tag: "C",  cloud: "#ffffff", frozenColor: "#e0f2fe", type: "standard", gas: "Water Vapor" },
    { name: "Salt Water",  color: "#2563eb", freeze: -2,   boil: 102,  tag: "C",  cloud: "#f1f5f9", frozenColor: "#bfdbfe", type: "standard", gas: "Water Vapor" },
    { name: "Heavy Water", color: "#60a5fa", freeze: 3.8,  boil: 101,  tag: "C",  cloud: "#e0f2fe", frozenColor: "#93c5fd", type: "standard", gas: "Deuterium" },
    { name: "Peroxide",    color: "#7dd3fc", freeze: -0.4, boil: 150,  tag: "O",  cloud: "#e0f2fe", frozenColor: "#e0f2fe", type: "standard", gas: "Oxygen" },
    { name: "Vinegar",     color: "#fde047", freeze: -2,   boil: 118,  tag: "C",  cloud: "#fef9c3", frozenColor: "#facc15", type: "acid",     gas: "Acetic Acid" },
    { name: "Brine",       color: "#0284c7", freeze: -21,  boil: 108,  tag: "C",  cloud: "#f0f9ff", frozenColor: "#bae6fd", type: "standard", gas: "Chlorine" },
    { name: "Methane",     color: "#38bdf8", freeze: -182, boil: -161, tag: "C",  cloud: "#bae6fd", frozenColor: "#bae6fd", type: "volatile", gas: "Methane" },
    { name: "Ethane",      color: "#0ea5e9", freeze: -183, boil: -88,  tag: "C",  cloud: "#e0f2fe", frozenColor: "#7dd3fc", type: "volatile", gas: "Ethane" },
    { name: "Nitrogen",    color: "#60a5fa", freeze: -210, boil: -195, tag: "N",  cloud: "#f1f5f9", frozenColor: "#93c5fd", type: "volatile", gas: "Nitrogen" },
    { name: "Ammonia",     color: "#2dd4bf", freeze: -77,  boil: -33,  tag: "N",  cloud: "#ccfbf1", frozenColor: "#5eead4", type: "acid",     gas: "Ammonia" },
    { name: "Chlorine",    color: "#a3e635", freeze: -101, boil: -34,  tag: "Cl", cloud: "#d9f99d", frozenColor: "#84cc16", type: "acid",     gas: "Chlorine Gas" },
    { name: "Sulfuric Acid", color: "#facc15", freeze: 10,  boil: 337,  tag: "S",  cloud: "#fef08a", frozenColor: "#eab308", type: "acid",    gas: "Sulfur Dioxide" },
    { name: "Nitric Acid",   color: "#fb7185", freeze: -42, boil: 83,   tag: "N",  cloud: "#fca5a5", frozenColor: "#f43f5e", type: "acid",    gas: "Nitrogen Dioxide" },
    { name: "Lava",        color: "#ff4500", freeze: 700,  boil: 3000, tag: "Si", cloud: "#57534e", frozenColor: "#292524", type: "magma",    gas: "Silicate Vapor" },
    { name: "Mercury",     color: "#cbd5e1", freeze: -39,  boil: 357,  tag: "Fe", cloud: "#e2e8f0", frozenColor: "#94a3b8", type: "metal",    gas: "Mercury Vapor" },
    { name: "Crude Oil",   color: "#020617", freeze: -57,  boil: 200,  tag: "C",  cloud: "#52525b", frozenColor: "#000000", type: "viscous",  gas: "Petroleum Gas" },
    { name: "Blood",       color: "#dc2626", freeze: -2,   boil: 100,  tag: "Bio",cloud: "#fca5a5", frozenColor: "#991b1b", type: "organic",  gas: "Iron Oxide" },
    { name: "Slime",       color: "#86efac", freeze: 0,    boil: 110,  tag: "Bio",cloud: "#bbf7d0", frozenColor: "#22c55e", type: "organic",  gas: "Methane" },
];

const SOLIDS = [
    { name: "Silicate",   color: "#78716c", tag: "Si", roughness: 1.0, type: "rock", melt: 1200 },
    { name: "Basalt",     color: "#3f3f46", tag: "Si", roughness: 1.0, type: "rock", melt: 1100 },
    { name: "Granite",    color: "#a1a1aa", tag: "Si", roughness: 1.3, type: "rock", melt: 1215 },
    { name: "Sandstone",  color: "#f59e0b", tag: "Si", roughness: 0.5, type: "rock", melt: 1300 },
    { name: "Limestone",  color: "#e5e5e5", tag: "C",  roughness: 0.8, type: "rock", melt: 900 },
    { name: "Obsidian",   color: "#18181b", tag: "Si", roughness: 1.1, type: "glass", melt: 1000 },
    { name: "Pumice",     color: "#d4d4d8", tag: "Si", roughness: 1.5, type: "rock", melt: 1200 },
    { name: "Regolith",   color: "#737373", tag: "Si", roughness: 1.4, type: "dust", melt: 1200 },
    { name: "Slate",      color: "#475569", tag: "Si", roughness: 0.9, type: "rock", melt: 1200 },
    { name: "Marble",     color: "#f3f4f6", tag: "C",  roughness: 0.7, type: "rock", melt: 1200 },
    { name: "Water Ice",  color: "#e2e8f0", tag: "C",  roughness: 0.7, type: "ice", melt: 0 },
    { name: "Dry Ice",    color: "#eff6ff", tag: "C",  roughness: 0.4, type: "ice", melt: -78 },
    { name: "Blue Ice",   color: "#bfdbfe", tag: "C",  roughness: 0.9, type: "ice", melt: 0 },
    { name: "Methane Ice",color: "#7dd3fc", tag: "C",  roughness: 0.5, type: "ice", melt: -182 },
    { name: "Iron Ore",   color: "#b91c1c", tag: "Fe", roughness: 1.2, type: "metal", melt: 1538 },
    { name: "Gold Vein",  color: "#facc15", tag: "Fe", roughness: 1.0, type: "metal", melt: 1064 },
    { name: "Copper Ox",  color: "#34d399", tag: "Fe", roughness: 0.8, type: "metal", melt: 1085 },
    { name: "Titanium",   color: "#94a3b8", tag: "Fe", roughness: 0.9, type: "metal", melt: 1668 },
    { name: "Bone",       color: "#fef3c7", tag: "Bio", roughness: 0.9, type: "organic", melt: 200 }
];

function hexToHSL(hex) {
    let r = parseInt(hex.substring(1,3), 16) / 255;
    let g = parseInt(hex.substring(3,5), 16) / 255;
    let b = parseInt(hex.substring(5,7), 16) / 255;
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) { h = s = 0; } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        } h /= 6;
    } return { h: h * 360, s: s * 100, l: l * 100 };
}
function hslToHex(h, s, l) {
    l /= 100; const a = s * Math.min(l, 1 - l) / 100;
    const f = n => { const k = (n + h / 30) % 12; const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1); return Math.round(255 * color).toString(16).padStart(2, '0'); };
    return `#${f(0)}${f(8)}${f(4)}`;
}
function artColor(hex, lShift, sShift = 0, hShift = 0) {
    const hsl = hexToHSL(hex);
    let newL = Math.max(6, Math.min(95, hsl.l + lShift));
    let newS = Math.max(0, Math.min(100, hsl.s + sShift));
    let newH = (hsl.h + hShift) % 360; if (newH < 0) newH += 360;
    return hslToHex(newH, newS, newL);
}
function createRNG(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) { hash = ((hash << 5) - hash) + str.charCodeAt(i); hash = hash & hash; }
    let seed = (hash >>> 0) || 1;
    return function() { seed |= 0; seed = seed + 0x6D2B79F5 | 0; let t = Math.imul(seed ^ seed >>> 15, 1 | seed); t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t; return ((t ^ t >>> 14) >>> 0) / 4294967296; };
}

const state = { seed: 'INIT', genId: 0, data: null, waterLevel: 50, shadow: 50, cloudsEnabled: true, rotation: 0, layerThresholds: [] };
const dom = {
    svg: document.getElementById('render-target'), defs: document.querySelector('defs'),
    gAxis: document.getElementById('planet-axis-group'), gLensContainer: document.getElementById('planet-lens-container'),
    gSurfaceSlider: document.getElementById('planet-surface-slider'), gTerrain: document.getElementById('group-terrain'),
    gLiquid: document.getElementById('group-liquid'), gIce: document.getElementById('group-ice'), gBio: document.getElementById('group-bio'),
    gCloudsRotator: document.getElementById('layer-clouds-rotator'), gGeoStructure: document.getElementById('geo-structure-layer'),
    gRingsBack: document.getElementById('layer-rings-back'), gRingsFront: document.getElementById('layer-rings-front'),
    rimLight: document.getElementById('rim-light'), terminator: document.getElementById('terminator'),
    seedInput: document.getElementById('seed-input'), btnRnd: document.getElementById('btn-rnd'), btnGen: document.getElementById('btn-gen'),
    btnDownload: document.getElementById('btn-download'), rngWater: document.getElementById('rng-water'), rngRotation: document.getElementById('rng-rotation'),
    rngShadow: document.getElementById('rng-shadow'), chkClouds: document.getElementById('chk-clouds'), lblWater: document.getElementById('lbl-water'),
    lblRotation: document.getElementById('lbl-rotation'), lblShadow: document.getElementById('lbl-shadow'), valTemp: document.getElementById('val-temp'),
    valLiquid: document.getElementById('val-liquid'), valSolid: document.getElementById('val-solid'), valAtmos: document.getElementById('val-atmos'), valLife: document.getElementById('val-life'),
};

// --- OPTIMIZATION: Shared Canvas & Scale ---
// We render at 50% scale (1500x500) and double the frequency in SVG.
// This is 4x faster and uses 75% less RAM than 3000x1000.
let sharedCanvas = null;
const BAKE_SCALE = 0.5; // 3000 -> 1500
const ORIG_W = 3000;
const ORIG_H = 1000;
let textureCache = [];

function clearTextureCache() {
    textureCache.forEach(url => URL.revokeObjectURL(url));
    textureCache = [];
}

async function bakeSVG(origWidth, origHeight, defs, content) {
    // Scale down dimensions for baking
    const width = origWidth * BAKE_SCALE;
    const height = origHeight * BAKE_SCALE;
    
    // Scale SVG content to fit new viewport
    const xml = `
    <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${origWidth} ${origHeight}">
        <defs>${defs}</defs>
        ${content}
    </svg>`;
    const blob = new Blob([xml], {type: "image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            if (!sharedCanvas) sharedCanvas = document.createElement('canvas');
            sharedCanvas.width = width;
            sharedCanvas.height = height;
            const ctx = sharedCanvas.getContext('2d', { alpha: true });
            ctx.clearRect(0,0,width,height);
            ctx.drawImage(img, 0, 0);
            sharedCanvas.toBlob(b => {
                const finalUrl = URL.createObjectURL(b);
                textureCache.push(finalUrl);
                URL.revokeObjectURL(url);
                resolve(finalUrl);
            }, 'image/png');
        };
        img.onerror = () => { console.error("Bake error"); resolve(null); }
        img.src = url;
    });
}

function createSVGLensURI() {
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512"><defs><radialGradient id="l"><stop offset="0%" stop-color="#808080"/><stop offset="100%" stop-color="#ffffff"/></radialGradient></defs><rect width="512" height="512" fill="url(#l)"/></svg>`;
    return "data:image/svg+xml;base64," + btoa(svg);
}

function generatePlanetData(rng) {
    let baseTemp = Math.floor(rng() * 450 - 150);
    if (rng() > 0.92) baseTemp += Math.floor(rng() * 4500);
    if (rng() < 0.12) baseTemp -= 150;
    const equatorOffset = Math.floor(rng() * 50 + 20), poleOffset = Math.floor(rng() * 80 + 40);
    const maxT = baseTemp + equatorOffset, minT = baseTemp - poleOffset, CtoK = (c) => c + 273.15, baseK = CtoK(baseTemp);
    const validSolids = SOLIDS.filter(s => !(s.type === 'ice' && baseTemp > s.melt));
    let solid = validSolids.length > 0 ? validSolids[Math.floor(rng() * validSolids.length)] : { name: "Scorched Crust", color: "#1a0500", tag: "Si", roughness: 1.2, type: "rock", melt: 9999 };
    const solidMeltK = CtoK(solid.melt);
    let solidName = solid.name;
    if (baseK > solidMeltK * 3) { solidName = `Molten ${solid.name}`; solid = { ...solid, color: artColor(solid.color, 25, 15, 5) }; }
    const potentialLiquids = LIQUIDS.filter(l => baseTemp > l.freeze);
    let liquid, oceanName, liquidState = "none", cloudColor, atmosContribution = 0;
    if (potentialLiquids.length > 0) {
        liquid = potentialLiquids[Math.floor(rng() * potentialLiquids.length)]; oceanName = liquid.name; cloudColor = liquid.cloud;
        const liquidBoilK = CtoK(liquid.boil);
        if (baseK > liquidBoilK * 3) { liquidState = "sediment"; oceanName = `${liquid.name} Sediment`; liquid = { ...liquid, color: artColor(liquid.color, -40, -30), tag: "Dry" }; cloudColor = "#59544f"; atmosContribution = 0.8; }
        else if (baseK > liquidBoilK) { liquidState = "boiling"; oceanName = `Boiling ${liquid.name}`; atmosContribution = 0.4; }
        else { liquidState = "liquid"; atmosContribution = 0.1; }
    } else { liquidState = "none"; oceanName = "None"; liquid = { name: "None", tag: "-", frozenColor: "#a1a1aa", cloud: "#a1a1aa" }; cloudColor = "#a1a1aa"; }
    let atmosName = "None", atmosDensity = 0;
    if (rng() > 0.2) { 
        atmosDensity = Math.max(0, Math.min(1, rng() * 0.3 + atmosContribution));
        if (liquidState === "sediment") { atmosDensity = 0.9 + (rng() * 0.1); atmosName = `Dense Vaporized ${liquid.name}`; }
        else if (atmosDensity < 0.05) { atmosName = "Trace Gases"; }
        else { atmosName = `${atmosDensity > 0.7 ? "Dense" : atmosDensity > 0.35 ? "Moderate" : "Thin"} ${(liquid.gas && liquidState !== "none") ? liquid.gas : "Inert Mix"}`; }
    } else { atmosName = "Vacuum"; }
    let hasLife = false, lifeType = "None", bioColor = null, bioMinT = 0, bioMaxT = 0;
    if (liquidState === "liquid") {
        if (["Water", "Salt Water"].includes(liquid.name) && baseTemp > -15 && baseTemp < 60) { hasLife = true; lifeType = "Carbon-Based"; bioColor = "#10b981"; bioMinT = -15; bioMaxT = 60; }
        else if (baseTemp > 200 && baseTemp < 1000 && solid.tag === "Si") { hasLife = true; lifeType = "Silicon-Based"; bioColor = "#9333ea"; bioMinT = 200; bioMaxT = 1000; }
    }
    const getLatForTemp = (t) => (maxT === minT) ? 0.5 : (maxT - t) / (maxT - minT);
    let latBoil = getLatForTemp(liquid.boil || 9999), latFreeze = getLatForTemp(liquid.freeze || 9998);
    if (liquidState === "sediment") latBoil = -2.0;
    let suggestedWater = (liquidState === "none" || liquidState === "sediment") ? Math.floor(rng() * 15) : Math.floor(rng() * 40 + 30);
    if (hasLife) suggestedWater = Math.floor(rng() * 20 + 45);
    // OPTIMIZATION: Compensate frequency for scale down
    const rawFreq = 0.006 - ((solid.roughness * 0.5) * 0.0045);
    // When baking at 0.5x, we multiply freq by 1/0.5 = 2.0 to keep visual consistency
    const baseFreq = rawFreq * (1/BAKE_SCALE); 

    return { baseTemp, maxT, minT, solid, liquid, latBoil, latFreeze, oceanName, solidName, atmosName, atmosDensity, cloudHex: cloudColor, hasLife, lifeType, bioColor, bioMinT, bioMaxT, tilt: rng() * 45, rings: rng() < 0.10, baseFreq, suggestedWater, roughness: solid.roughness * (0.5 + rng()) };
}

function generatePalette(data) {
    const s = data.solid.color;
    return [artColor(s, -45, 10, -15), artColor(s, -30, 5, -10), artColor(s, -15, 0, -5), s, artColor(s, 15, 0, 5), artColor(s, 30, -10, 10), artColor(s, 50, -20, 15)];
}
function getTagHtml(tag) { const map = { 'C':'tag-c', 'Si':'tag-si', 'Fe':'tag-fe', 'X':'tag-x', 'N':'tag-none', 'O':'tag-none', 'S':'tag-fe', 'Bio':'tag-bio' }; return `<span class="tag ${map[tag] || 'tag-none'}">[${tag}]</span>`; }

async function fullRebuild() {
    state.genId++; const currentGenId = state.genId;
    dom.btnGen.disabled = true; dom.btnGen.innerText = "Rendering...";
    clearTextureCache();
    dom.defs.querySelectorAll('.dynamic-def').forEach(el => el.remove());
    [dom.gTerrain, dom.gLiquid, dom.gIce, dom.gBio, dom.gCloudsRotator, dom.gGeoStructure, dom.gRingsBack, dom.gRingsFront].forEach(e => e.innerHTML = '');

    const rng = createRNG(state.seed);
    state.data = generatePlanetData(rng);
    const data = state.data;
    const palette = generatePalette(data);

    dom.valTemp.innerHTML = `${data.baseTemp}Â°C <span style="font-size: 0.8em; opacity: 0.7;">(<span style="color: #60a5fa">${data.minT}Â°</span> / <span style="color: #f87171">${data.maxT}Â°</span>)</span>`;
	dom.valLiquid.innerHTML = data.oceanName + getTagHtml(data.liquid.tag);
    dom.valSolid.innerHTML = data.solidName + getTagHtml(data.solid.tag);
    dom.valAtmos.innerText = data.atmosName;
    dom.valLife.innerHTML = data.hasLife ? data.lifeType : "STERILE";
    dom.valLife.className = `data-val ${data.hasLife ? 'tag-life' : 'tag-dead'}`;

    dom.gAxis.setAttribute("transform", `rotate(${data.tilt}, 500, 500)`);

    const lensFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    lensFilter.setAttribute("id", `lens-${state.seed}`);
    lensFilter.classList.add('dynamic-def');
    lensFilter.innerHTML = `<feImage href="${createSVGLensURI()}" result="l" x="0" y="0" width="1000" height="1000" preserveAspectRatio="none"/><feDisplacementMap in="SourceGraphic" in2="l" scale="120" xChannelSelector="R" yChannelSelector="G" />`;
    dom.defs.appendChild(lensFilter);
    dom.gLensContainer.setAttribute("filter", `url(#lens-${state.seed})`);

    // --- BAKING (Optimized) ---
    // Note: Frequencies multiplied by 2 because baking at 0.5 resolution
    const terraNoiseDef = `<filter id="bake-noise"><feTurbulence type="fractalNoise" baseFrequency="${data.baseFreq}" numOctaves="6" seed="${Math.floor(rng()*1000)}" stitchTiles="stitch" result="t"/><feColorMatrix type="saturate" values="0" in="t" result="g"/><feColorMatrix in="g" type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1" result="bw"/><feComponentTransfer in="bw"><feFuncR type="linear" slope="4" intercept="-1.5"/><feFuncG type="linear" slope="4" intercept="-1.5"/><feFuncB type="linear" slope="4" intercept="-1.5"/></feComponentTransfer></filter>`;
    const terraNoisePromise = bakeSVG(ORIG_W, ORIG_H, terraNoiseDef, `<rect width="${ORIG_W}" height="${ORIG_H}" filter="url(#bake-noise)"/>`);

    const iceNoiseDef = `<filter id="bake-ice"><feTurbulence type="fractalNoise" baseFrequency="${0.02 * (1/BAKE_SCALE)}" numOctaves="4" seed="500" result="f"/><feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.4 0" /></filter>`;
    const iceTexturePromise = bakeSVG(ORIG_W, ORIG_H, iceNoiseDef, `<rect width="${ORIG_W}" height="${ORIG_H}" fill="${data.liquid.frozenColor}" filter="url(#bake-ice)"/>`);

    let cloudTexturePromise = Promise.resolve(null);
    if (state.cloudsEnabled && data.atmosDensity > 0.05) {
        // Optimized cloud geometry (lower poly) and adjusted noise
        const cloudFilterDef = `<filter id="bake-cloud"><feTurbulence type="fractalNoise" baseFrequency="${0.015 * (1/BAKE_SCALE)}" numOctaves="4" result="n"/><feDisplacementMap in="SourceGraphic" in2="n" scale="25" result="d"/><feGaussianBlur in="d" stdDeviation="2"/><feComponentTransfer><feFuncA type="linear" slope="5" intercept="-1.5"/></feComponentTransfer></filter>`;
        cloudTexturePromise = bakeSVG(ORIG_W, ORIG_H, cloudFilterDef, `<g filter="url(#bake-cloud)">${generateCloudsSVG(rng, data)}</g>`);
    }

    const [terraURL, iceURL, cloudURL] = await Promise.all([terraNoisePromise, iceTexturePromise, cloudTexturePromise]);
    if (state.genId !== currentGenId) return;

    // --- ASSEMBLY ---
    generateGeology(rng, data);
    generateSolidLayers(rng, data, palette, terraURL);

    createOrganicZoneMask("mask-liquid", data.latBoil, data.latFreeze, 0, "liquid");
    createOrganicZoneMask("mask-ice", data.latBoil, data.latFreeze, 0, "ice");
    const lMaskId = `mask-liquid-final-${state.seed}`;
    createCompositeMask(lMaskId, "mask-liquid", terraURL, state.waterLevel/100, true, 120);

    const oGrad = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    oGrad.setAttribute("id", `grad-ocean-${state.seed}`); oGrad.setAttribute("cx", "50%"); oGrad.setAttribute("cy", "50%");
    oGrad.classList.add('dynamic-def');
    oGrad.innerHTML = `<stop offset="0%" stop-color="${artColor(data.liquid.color, -5, 5)}"/><stop offset="30%" stop-color="${data.liquid.color}"/>`;
    dom.defs.appendChild(oGrad);

    const liquidRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    liquidRect.setAttribute("width", ORIG_W); liquidRect.setAttribute("height", ORIG_H); liquidRect.setAttribute("x", "-1000");
    liquidRect.setAttribute("fill", `url(#grad-ocean-${state.seed})`); liquidRect.setAttribute("mask", `url(#${lMaskId})`);
    if (data.liquid.type !== "magma") liquidRect.setAttribute("filter", "url(#liquid-blur)");
    dom.gLiquid.appendChild(liquidRect);

    // Optimized reflection
    const reflection = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
    reflection.setAttribute("cx","500"); reflection.setAttribute("cy","300"); reflection.setAttribute("rx","150"); reflection.setAttribute("ry","100");
    reflection.setAttribute("fill", "white"); reflection.setAttribute("opacity", "0.3"); reflection.setAttribute("transform", "rotate(-45, 500, 300)");
    reflection.setAttribute("filter", "url(#geo-blur)"); dom.gLiquid.appendChild(reflection);

    const iceRect = document.createElementNS("http://www.w3.org/2000/svg", "image");
    iceRect.setAttribute("width", ORIG_W); iceRect.setAttribute("height", ORIG_H); iceRect.setAttribute("x", "-1000");
    iceRect.setAttribute("href", iceURL); iceRect.setAttribute("mask", `url(#mask-ice)`);
    iceRect.setAttribute("preserveAspectRatio", "none"); // Handle scale stretch
    dom.gIce.appendChild(iceRect);

    if (data.hasLife) {
        createOrganicBandMask("mask-bio-zone", data.maxT, data.minT, data.bioMinT, data.bioMaxT, 0);
        const landMaskId = `mask-land-only-${state.seed}`;
        createCompositeMask(landMaskId, null, terraURL, state.waterLevel/255, false); 
        const gBio = document.createElementNS("http://www.w3.org/2000/svg", "g");
        gBio.setAttribute("mask", `url(#${landMaskId})`);
        const bioRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        bioRect.setAttribute("width", ORIG_W); bioRect.setAttribute("height", ORIG_H); bioRect.setAttribute("x", "-1000");
        bioRect.setAttribute("fill", data.bioColor); bioRect.setAttribute("mask", `url(#mask-bio-zone)`);
        bioRect.setAttribute("opacity", "0.7"); bioRect.style.mixBlendMode = "multiply"; 
        gBio.appendChild(bioRect); dom.gBio.appendChild(gBio);
    }

    if (cloudURL) {
        const cloudImg = document.createElementNS("http://www.w3.org/2000/svg", "image");
        cloudImg.setAttribute("width", ORIG_W); cloudImg.setAttribute("height", ORIG_H); cloudImg.setAttribute("x", "-1000");
        cloudImg.setAttribute("href", cloudURL); cloudImg.setAttribute("opacity", "0.6");
        cloudImg.setAttribute("preserveAspectRatio", "none");
        dom.gCloudsRotator.appendChild(cloudImg);
    }
    
    const gradAtmos = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    gradAtmos.setAttribute("id", "grad-atmos"); gradAtmos.classList.add('dynamic-def');
    gradAtmos.innerHTML = `<stop offset="85%" stop-color="${data.cloudHex}" stop-opacity="0"/><stop offset="95%" stop-color="${data.cloudHex}" stop-opacity="${data.atmosDensity * 0.4}"/><stop offset="100%" stop-color="${data.cloudHex}" stop-opacity="${data.atmosDensity}"/>`;
    dom.defs.appendChild(gradAtmos);
    dom.rimLight.setAttribute('stroke', artColor(data.cloudHex, 20, -10, 0));

    if (data.rings) generateRings(rng, data);

    dom.btnGen.disabled = false; dom.btnGen.innerText = "Update View";
    softUpdate();
}

function createOrganicZoneMask(id, latBoil, latFreeze, tilt, type) {
    const gradId = `grad-${id}-${state.seed}`;
    const grad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    grad.setAttribute("id", gradId); grad.setAttribute("x2", "0"); grad.setAttribute("y2", "1");
    grad.setAttribute("gradientTransform", `rotate(${tilt}, 0.5, 0.5)`); grad.classList.add('dynamic-def');
    const boT = 0.5 - latBoil*0.5, frT = 0.5 - latFreeze*0.5, boB = 0.5 + latBoil*0.5, frB = 0.5 + latFreeze*0.5, s = 0.02;
    let stops = (type === "liquid") ? 
        `<stop offset="0%" stop-color="white"/><stop offset="${(boT-s)*100}%" stop-color="white"/><stop offset="${(boT+s)*100}%" stop-color="#c0c0c0"/><stop offset="${(boB-s)*100}%" stop-color="#c0c0c0"/><stop offset="${(boB+s)*100}%" stop-color="white"/><stop offset="100%" stop-color="white"/>` : 
        `<stop offset="0%" stop-color="white"/><stop offset="${(frT-s)*100}%" stop-color="white"/><stop offset="${(frT+s)*100}%" stop-color="#c0c0c0"/><stop offset="${(frB-s)*100}%" stop-color="#c0c0c0"/><stop offset="${(frB+s)*100}%" stop-color="white"/><stop offset="100%" stop-color="white"/>`;
    grad.innerHTML = stops; dom.defs.appendChild(grad);
    const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask"); mask.setAttribute("id", id); mask.classList.add('dynamic-def');
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("width", ORIG_W); rect.setAttribute("height", ORIG_H); rect.setAttribute("x", "-1000");
    rect.setAttribute("fill", `url(#${gradId})`); rect.setAttribute("filter", "url(#zone-warp)");
    mask.appendChild(rect); dom.defs.appendChild(mask);
}

function createOrganicBandMask(id, maxT, minT, targetMin, targetMax, tilt) {
    const getLat = (t) => (maxT - t) / (maxT - minT);
    let lat1 = Math.max(0, Math.min(1, getLat(targetMax))), lat2 = Math.max(0, Math.min(1, getLat(targetMin)));
    const y1t = 0.5 - lat1*0.5, y2t = 0.5 - lat2*0.5, y1b = 0.5 + lat1*0.5, y2b = 0.5 + lat2*0.5, s = 0.05;
    const gradId = `grad-${id}-${state.seed}`;
    const grad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    grad.setAttribute("id", gradId); grad.setAttribute("y2", "1"); grad.setAttribute("gradientTransform", `rotate(${tilt}, 0.5, 0.5)`); grad.classList.add('dynamic-def');
    grad.innerHTML = `<stop offset="0%" stop-color="#c0c0c0"/><stop offset="${(y2t-s)*100}%" stop-color="#c0c0c0"/><stop offset="${(y2t+s)*100}%" stop-color="white"/><stop offset="${(y1t-s)*100}%" stop-color="white"/><stop offset="${(y1t+s)*100}%" stop-color="#c0c0c0"/><stop offset="${(y1b-s)*100}%" stop-color="#c0c0c0"/><stop offset="${(y1b+s)*100}%" stop-color="white"/><stop offset="${(y2b-s)*100}%" stop-color="white"/><stop offset="${(y2b+s)*100}%" stop-color="#c0c0c0"/><stop offset="100%" stop-color="#c0c0c0"/>`;
    dom.defs.appendChild(grad);
    const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask"); mask.setAttribute("id", id); mask.classList.add('dynamic-def');
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("width", ORIG_W); rect.setAttribute("height", ORIG_H); rect.setAttribute("x", "-1000");
    rect.setAttribute("fill", `url(#${gradId})`); rect.setAttribute("filter", "url(#zone-warp)");
    mask.appendChild(rect); dom.defs.appendChild(mask);
}

function createCompositeMask(id, thermalMaskId, noiseURL, threshold, invert, slopeVal = 50) {
    const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask"); mask.setAttribute("id", id); mask.classList.add('dynamic-def');
    const threshId = `thresh-${id}`;
    const filter = document.createElementNS("http://www.w3.org/2000/svg", "filter"); filter.setAttribute("id", threshId); filter.setAttribute("color-interpolation-filters", "sRGB"); filter.classList.add('dynamic-def');
    let slope = slopeVal, intercept = -(threshold * slope) + 0.5;
    if (invert) { slope = -slopeVal; intercept = (threshold * slopeVal) + 0.5; }
    filter.innerHTML = `<feComponentTransfer><feFuncR type="linear" slope="${slope}" intercept="${intercept}"/><feFuncG type="linear" slope="${slope}" intercept="${intercept}"/><feFuncB type="linear" slope="${slope}" intercept="${intercept}"/></feComponentTransfer>`;
    dom.defs.appendChild(filter);
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const r1 = document.createElementNS("http://www.w3.org/2000/svg", "image");
    r1.setAttribute("width", ORIG_W); r1.setAttribute("height", ORIG_H); r1.setAttribute("x", "-1000"); r1.setAttribute("href", noiseURL); r1.setAttribute("filter", `url(#${threshId})`);
    r1.setAttribute("preserveAspectRatio", "none");
    if (thermalMaskId) r1.setAttribute("mask", `url(#${thermalMaskId})`);
    g.appendChild(r1); mask.appendChild(g); dom.defs.appendChild(mask);
}

function generateSolidLayers(rng, data, palette, noiseURL) {
    state.layerThresholds = [];
    let stops = [0], current = 0, gapBase = (data.solid.type === 'crystal') ? 0.03 : (data.solid.roughness < 0.6) ? 0.08 : 0.05;
    for(let i=1; i<palette.length; i++) { current += gapBase; stops.push(current); gapBase *= 1.08; }
    const maxVal = stops[stops.length-1];
    const normalizedStops = stops.map(v => 0.08 + (v / maxVal) * 0.75);

    palette.forEach((color, i) => {
        const maskID = `mask-layer-${i}-${state.seed}`, threshID = `thresh-layer-${i}`;
        const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask"); mask.setAttribute("id", maskID); mask.classList.add('dynamic-def');
        const gMask = document.createElementNS("http://www.w3.org/2000/svg", "g");
        const rectNoise = document.createElementNS("http://www.w3.org/2000/svg", "image");
        rectNoise.setAttribute("width", ORIG_W); rectNoise.setAttribute("height", ORIG_H); rectNoise.setAttribute("x", "-1000");
        rectNoise.setAttribute("href", noiseURL); rectNoise.setAttribute("preserveAspectRatio", "none");
        gMask.appendChild(rectNoise);
        const threshFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
        threshFilter.setAttribute("id", threshID); threshFilter.setAttribute("color-interpolation-filters", "sRGB"); threshFilter.classList.add('dynamic-def');
        const level = Math.max(0, Math.min(1, normalizedStops[i] + ((rng() * 0.04) - 0.02)));
        state.layerThresholds.push(level);
        const slope = 60, intercept = -(level * slope);
        threshFilter.innerHTML = `<feComponentTransfer><feFuncR type="linear" slope="${slope}" intercept="${intercept}"/><feFuncG type="linear" slope="${slope}" intercept="${intercept}"/><feFuncB type="linear" slope="${slope}" intercept="${intercept}"/></feComponentTransfer>`;
        dom.defs.appendChild(threshFilter);
        gMask.setAttribute("filter", `url(#${threshID})`); mask.appendChild(gMask); dom.defs.appendChild(mask);
        const layerRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        layerRect.setAttribute("width", ORIG_W); layerRect.setAttribute("height", ORIG_H); layerRect.setAttribute("x", "-1000");
        layerRect.setAttribute("fill", color); layerRect.setAttribute("mask", `url(#${maskID})`);
        dom.gTerrain.appendChild(layerRect);
    });
}

function generateGeology(rng, data) {
    dom.gGeoStructure.innerHTML = '';
    if (data.roughness <= 0.5) return;
    const singleTile = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const count = Math.ceil(8 * data.roughness);
    for (let i = 0; i < count; i++) {
        const lat1 = rng()*2-1, lon1 = rng()*6.28, lat2 = rng()*2-1, lon2 = lon1 + rng();
        let d = "";
        for(let t=0; t<=12; t++) {
            const step = t/12, lat = lat1+(lat2-lat1)*step, lon = lon1+(lon2-lon1)*step;
            const p = projectSphere(450, lat, lon, 0); if(p.z > -100) d += (t===0?"M":"L") + ` ${p.x} ${p.y}`;
        }
        if(d) {
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", d); path.setAttribute("fill", "none"); path.setAttribute("stroke", "white");
            path.setAttribute("stroke-width", rng() * 30 + 10); path.setAttribute("filter", "url(#geo-blur)"); path.setAttribute("opacity", 0.6 * data.roughness);
            singleTile.appendChild(path);
        }
    }
    const wrapper = document.createElementNS("http://www.w3.org/2000/svg", "g");
    wrapper.innerHTML = `<g transform="translate(-1000,0)">${singleTile.innerHTML}</g><g>${singleTile.innerHTML}</g><g transform="translate(1000,0)">${singleTile.innerHTML}</g>`;
    dom.gGeoStructure.appendChild(wrapper);
}

function generateCloudsSVG(rng, data) {
    const R = 640;
    // Optimization: Reduced steps from 60 to 40
    const generateCloudSpine = (yBase, width, xOffset) => {
        const points = []; const steps = 40, startX = -width/2+xOffset, stepSize = width/steps;
        let yDrift = 0;
        for (let i = 0; i <= steps; i++) {
            const xRel = startX + i*stepSize, xRatio = xRel/R, sphereCurve = (xRatio*xRatio)*yBase*-0.8;
            yDrift = (yDrift + (rng()-0.5)) * 0.95;
            points.push({ x: 500+xRel, y: 500+(yBase+sphereCurve+yDrift) });
        } return points;
    };
    const generateCloudShapeFromSpine = (spine, opts) => {
        if (spine.length < 3) return "";
        const top = [], bot = []; let thick = opts.baseThickness;
        for (let i = 0; i < spine.length; i++) {
            const p = spine[i], next = spine[Math.min(spine.length-1, i+1)], prev = spine[Math.max(0, i-1)];
            let nx = -(next.y-prev.y), ny = next.x-prev.x; const len = Math.sqrt(nx*nx+ny*ny);
            if (len>0) { nx/=len; ny/=len; }
            const prog = i/(spine.length-1), taper = Math.pow(Math.sin(prog*Math.PI), opts.taperPower);
            thick = Math.max(5, thick+(rng()-0.5)*(opts.thicknessVariance/5));
            const cThick = thick*taper, jag = (rng()-0.5)*opts.edgeNoise*taper;
            top.push({x:p.x+nx*(cThick*0.5+jag), y:p.y+ny*(cThick*0.5+jag)});
            bot.push({x:p.x-nx*(cThick*0.5+jag), y:p.y-ny*(cThick*0.5+jag)});
        }
        let d = `M${top[0].x.toFixed(1)} ${top[0].y.toFixed(1)}`;
        for(let i=1;i<top.length;i++) d+=`L${top[i].x.toFixed(1)} ${top[i].y.toFixed(1)}`;
        for(let i=bot.length-1;i>=0;i--) d+=`L${bot[i].x.toFixed(1)} ${bot[i].y.toFixed(1)}`;
        return d+"Z";
    };

    const clusterCount = Math.floor(rng()*2)+3, range = 1.85, zoneSize = range/clusterCount;
    let tileInner = "";
    for (let i = 0; i < clusterCount; i++) {
        const zoneTop = -(range/2) + (i * zoneSize);
        const yBase = (zoneTop + rng()*zoneSize*0.8 + zoneSize*0.1) * R;
        const maxChord = Math.sqrt(Math.max(0, R*R - yBase*yBase)) * 2;
        const width = maxChord * (0.2 + rng()*0.7);
        const spine = generateCloudSpine(yBase, width, (rng()*(maxChord-width))-(maxChord-width)/2);
        const baseColor = artColor(data.cloudHex, Math.abs(yBase/R)*-15, Math.abs(yBase/R)*-5);
        // Optimization: Reduced layers slightly
        const layers = Math.floor(rng()*3)+3;
        for(let j=0; j<=layers; j++) {
             const subL = Math.floor(spine.length*(1-(j*0.08))), start = Math.floor(rng()*(spine.length-subL));
             const scale = 1.0;
             const subSpine = spine.slice(start, start+subL).map((p, k, arr) => {
                const next = arr[Math.min(arr.length-1, k+1)], prev = arr[Math.max(0, k-1)];
                let nx = -(next.y-prev.y), ny = next.x-prev.x; const l = Math.sqrt(nx*nx+ny*ny); if(l>0){nx/=l;ny/=l;}
                return {x:p.x+nx*(j*14*scale*(yBase<0?-1:1))+(rng()-0.5)*20*scale, y:p.y+ny*(j*14*scale*(yBase<0?-1:1))};
             });
             const d = generateCloudShapeFromSpine(subSpine, {baseThickness:(35-j*2)*scale, thicknessVariance:10, edgeNoise:(12+j)*scale, taperPower:0.5});
             if(d) tileInner += `<path d="${d}" fill="${artColor(baseColor, 40-j*10, -5)}" fill-opacity="0.6"/>`;
        }
    }
    return `<g transform="translate(-1000,0)">${tileInner}</g><g>${tileInner}</g><g transform="translate(1000,0)">${tileInner}</g>`;
}

function generateRings(rng, data) {
    dom.gRingsBack.innerHTML = ''; dom.gRingsFront.innerHTML = '';
    const tilt = data.tilt;
    if (rng() > 0.2) { // Solid Lines
        const ringBase = data.solid.color;
        for(let i=0; i<8; i++) {
            const r = 600 + i * 20, ry = r * 0.25, width = rng()*8+2, op = rng()*0.3+0.1, c = artColor(ringBase, i%2===0?20:-20, -10, 0);
            const pathBack = `<path d="M ${500+r*Math.cos(Math.PI)} ${500+ry*Math.sin(Math.PI)} A ${r} ${ry} 0 0 0 ${500+r} ${500}" stroke="${c}" fill="none" stroke-width="${width}" opacity="${op}" transform="rotate(${tilt},500,500)"/>`;
            const pathFront = `<path d="M ${500+r} ${500} A ${r} ${ry} 0 0 0 ${500-r} ${500}" stroke="${c}" fill="none" stroke-width="${width}" opacity="${op}" transform="rotate(${tilt},500,500)"/>`;
            dom.gRingsBack.innerHTML += pathBack; dom.gRingsFront.innerHTML += pathFront;
        }
    } else { // Particles - OPTIMIZED: Batching paths into groups
        const palette = [data.solid.color, data.liquid.frozenColor||"#e0f2fe"];
        const bands = [{s:540,e:650,d:0.8,c:200}, {s:670,e:800,d:0.5,c:200}, {s:810,e:825,d:0.3,c:30}];
        const persp = 0.25+rng()*0.15;
        // Group by approximate stroke width to minimize DOM nodes
        const batchesBack = {}, batchesFront = {};
        
        bands.forEach(band => {
            for (let i = 0; i < band.c; i++) {
                const p = rng(), r = band.s+p*(band.e-band.s), ry = r*persp, op = (band.d*0.3)*(0.5+rng()*0.5)+Math.sin(p*Math.PI*20)*0.1;
                if (op < 0.04) continue;
                const w = Math.floor(1+rng()*3), color = palette[Math.floor(rng()*2)];
                const key = `${w}-${color}`;
                if(!batchesBack[key]) { batchesBack[key] = ""; batchesFront[key] = ""; }
                
                const sxB = 500+r*Math.cos(Math.PI*2), syB = 500+ry*Math.sin(Math.PI*2), exB = 500+r*Math.cos(Math.PI), eyB = 500+ry*Math.sin(Math.PI);
                batchesBack[key] += `M ${sxB.toFixed(1)} ${syB.toFixed(1)} A ${r.toFixed(1)} ${ry.toFixed(1)} 0 0 0 ${exB.toFixed(1)} ${eyB.toFixed(1)} `;
                
                const sxF = 500+r*Math.cos(Math.PI), syF = 500+ry*Math.sin(Math.PI), exF = 500+r*Math.cos(0), eyF = 500+ry*Math.sin(0);
                batchesFront[key] += `M ${sxF.toFixed(1)} ${syF.toFixed(1)} A ${r.toFixed(1)} ${ry.toFixed(1)} 0 0 0 ${exF.toFixed(1)} ${eyF.toFixed(1)} `;
            }
        });
        
        const renderBatch = (batch, container) => {
            Object.keys(batch).forEach(key => {
                const [w, c] = key.split('-');
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("stroke", c); path.setAttribute("fill", "none");
                path.setAttribute("stroke-width", w); path.setAttribute("stroke-opacity", "0.2"); // Averaged opacity
                path.setAttribute("transform", `rotate(${tilt}, 500, 500)`);
                path.setAttribute("d", batch[key]);
                container.appendChild(path);
            });
        };
        renderBatch(batchesBack, dom.gRingsBack);
        renderBatch(batchesFront, dom.gRingsFront);
    }
}

function projectSphere(r, lat, lon, tilt) {
    let x = r*Math.cos(lat)*Math.sin(lon), y = r*Math.sin(lat), z = r*Math.cos(lat)*Math.cos(lon);
    let rad = tilt*(Math.PI/180), xT = x*Math.cos(rad)-y*Math.sin(rad), yT = x*Math.sin(rad)+y*Math.cos(rad);
    return { x: xT+500, y: -yT+500, z };
}

function softUpdate() {
    const shadowOp = state.shadow / 100;
    dom.terminator.setAttribute('opacity', shadowOp);
    dom.terminator.setAttribute('d', 'M 500,50 A 450,450 0 1,1 500,950 A 550,450 0 1,0 500,50');
    
    let grad = document.getElementById("shadow-grad");
    if(!grad) { grad = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient"); grad.setAttribute("id", "shadow-grad"); dom.defs.appendChild(grad); }
    grad.setAttribute("cx", "35%"); grad.setAttribute("cy", "35%");
    grad.innerHTML = `<stop offset="50%" stop-color="#050508" stop-opacity="0"/><stop offset="100%" stop-color="#050508" stop-opacity="${shadowOp}"/>`;

    dom.gCloudsRotator.style.display = (state.cloudsEnabled) ? 'block' : 'none';
    const waterFactor = state.waterLevel / 100;
    const updateFilterIntercept = (id, val) => { const f = document.getElementById(id); if(f) f.querySelectorAll('feFuncR,feFuncG,feFuncB').forEach(el=>el.setAttribute('intercept', val)); };
    
    if (state.layerThresholds.length) {
        state.layerThresholds.forEach((base, i) => updateFilterIntercept(`thresh-layer-${i}`, -((base + (waterFactor-0.5)*1.5) * 60)));
    }
    updateFilterIntercept(`thresh-mask-liquid-final-${state.seed}`, (waterFactor * 120) + 0.5);
    updateFilterIntercept(`thresh-mask-land-only-${state.seed}`, -(waterFactor * 50) + 0.5);

    const translate = -((state.rotation / 360) * ORIG_W) % ORIG_W;
    dom.gSurfaceSlider.setAttribute("transform", `translate(${translate}, 0)`);
    if(dom.gCloudsRotator.firstChild) dom.gCloudsRotator.firstChild.setAttribute("transform", `translate(${translate}, 0)`);
}

window.onload = () => {
    const bg = document.getElementById('starfield');
    for(let i=0; i<80; i++) {
        const s = document.createElement('div'); s.className = 'star';
        s.style.top = Math.random()*100+'%'; s.style.left = Math.random()*100+'%';
        s.style.width = Math.random()*2+'px'; s.style.height = s.style.width; s.style.animationDelay = Math.random()*5+'s';
        bg.appendChild(s);
    }
    const triggerRebuild = () => {
        state.seed = dom.seedInput.value.toUpperCase(); state.waterLevel = parseInt(dom.rngWater.value);
        state.rotation = parseInt(dom.rngRotation.value); state.shadow = parseInt(dom.rngShadow.value);
        state.cloudsEnabled = dom.chkClouds.checked; fullRebuild();
    }
    const handleManualUpdate = () => {
        state.waterLevel = parseInt(dom.rngWater.value); dom.lblWater.innerText = state.waterLevel + '%'; softUpdate();
    };
    dom.btnRnd.addEventListener('click', () => {
        const pfx = ["TERRA", "AQUA", "MAGMA", "CRYO", "XENO", "LUNA", "SOL", "VEGA", "NOVA", "ATLAS"];
        dom.seedInput.value = `${pfx[Math.floor(Math.random()*pfx.length)]}-${Math.floor(Math.random()*9999)}`;
        const tD = generatePlanetData(createRNG(dom.seedInput.value));
        dom.rngWater.value = tD.suggestedWater; dom.lblWater.innerText = tD.suggestedWater + '%';
        triggerRebuild();
    });
    dom.btnGen.addEventListener('click', triggerRebuild);
    dom.seedInput.addEventListener('change', triggerRebuild);
    dom.rngWater.addEventListener('input', handleManualUpdate);
    dom.rngShadow.addEventListener('input', () => { state.shadow = parseInt(dom.rngShadow.value); dom.lblShadow.innerText = state.shadow+'%'; softUpdate(); });
    dom.rngRotation.addEventListener('input', () => { state.rotation = parseInt(dom.rngRotation.value); dom.lblRotation.innerText = state.rotation+'Â°'; softUpdate(); });
    dom.chkClouds.addEventListener('change', () => { state.cloudsEnabled = dom.chkClouds.checked; softUpdate(); });
    dom.btnDownload.addEventListener('click', () => {
        const link = document.createElement('a'); link.download = `SB_PLANET_V10_OPT_${state.seed}.svg`;
        link.href = URL.createObjectURL(new Blob([dom.svg.outerHTML], {type: 'image/svg+xml;charset=utf-8'}));
        link.click();
    });
    
    // Init
    const iD = generatePlanetData(createRNG(dom.seedInput.value));
    dom.rngWater.value = iD.suggestedWater; dom.lblWater.innerText = iD.suggestedWater + '%';
    triggerRebuild();
};
</script>
</body>
</html>
