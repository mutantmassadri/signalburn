<!-- START OF FILE index.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SB PLANETGEN V12.5 - TURBO</title>
    <style>
        /* --- CORE VISUALS --- */
        :root {
            --c-bg: #050507;
            --c-panel: #141416;
            --c-border: #27272a;
            --c-accent: #3b82f6;
            --c-accent-glow: rgba(59, 130, 246, 0.5);
            --c-text: #e4e4e7;
            --c-text-dim: #a1a1aa;
            
            --f-mono: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
            --f-sans: system-ui, -apple-system, sans-serif;
        }

        * { box-sizing: border-box; outline: none; }

        body {
            background-color: var(--c-bg);
            color: var(--c-text);
            font-family: var(--f-sans);
            margin: 0;
            height: 100vh;
            display: grid;
            grid-template-columns: 1fr 380px;
            overflow: hidden;
        }

        /* --- LEFT: CANVAS AREA --- */
        .stage {
            position: relative;
            background: radial-gradient(circle at 50% 50%, #1a1a20 0%, #000 90%);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            cursor: grab;
        }
        .stage:active { cursor: grabbing; }

        /* THE 3D CANVAS */
        #webgl-canvas {
            width: 100%; height: 100%;
            z-index: 10;
        }

        /* HIDDEN TEXTURE BAKER */
        #texture-baker-container {
            position: absolute; top: -9999px; left: -9999px; visibility: hidden;
        }

        /* --- RIGHT: CONTROL DECK --- */
        .deck {
            background: var(--c-panel);
            border-left: 1px solid var(--c-border);
            padding: 0;
            display: flex; flex-direction: column;
            overflow-y: auto;
            box-shadow: -10px 0 40px rgba(0,0,0,0.5);
            z-index: 20;
        }

        .deck-header {
            padding: 20px;
            border-bottom: 1px solid var(--c-border);
            background: rgba(0,0,0,0.2);
        }

        h1 {
            font-family: var(--f-mono);
            font-size: 1.1rem;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--c-accent);
            text-shadow: 0 0 15px var(--c-accent-glow);
            display: flex; justify-content: space-between;
        }
        .version { font-size: 0.7em; opacity: 0.5; color: white; }

        .seed-row { display: flex; gap: 8px; }

        input[type="text"] {
            background: var(--c-bg); border: 1px solid var(--c-border); color: var(--c-text);
            font-family: var(--f-mono); padding: 12px; border-radius: 6px; flex: 1;
            font-size: 0.9rem; transition: border 0.2s;
        }
        input[type="text"]:focus { border-color: var(--c-accent); }

        .btn-icon {
            width: 44px; background: var(--c-bg); border: 1px solid var(--c-border);
            color: var(--c-text); border-radius: 6px; cursor: pointer; font-size: 1.2rem;
            transition: all 0.2s;
        }
        .btn-icon:hover { background: var(--c-border); color: #fff; }

        .controls { padding: 20px; display: flex; flex-direction: column; gap: 20px; }

        .section-title {
            font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1.5px;
            color: var(--c-text-dim); font-weight: 700; margin-bottom: 12px;
            display: flex; align-items: center; gap: 8px;
        }
        .section-title::after { content: ''; flex: 1; height: 1px; background: var(--c-border); }

        .btn-action {
            width: 100%; padding: 16px;
            background: linear-gradient(135deg, var(--c-accent) 0%, #2563eb 100%);
            border: none; color: white; font-weight: bold; text-transform: uppercase;
            letter-spacing: 1px; border-radius: 8px; cursor: pointer;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
            transition: transform 0.1s;
        }
        .btn-action:active { transform: scale(0.98); }
        .btn-action:disabled { opacity: 0.5; cursor: wait; filter: saturate(0); }

        /* DATA READOUT PANEL */
        .data-panel {
            background: #0f0f11; border: 1px solid var(--c-border);
            border-radius: 6px; padding: 12px; font-family: var(--f-mono); font-size: 0.75rem;
            display: grid; gap: 8px;
        }
        .data-row { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px dashed #27272a; padding-bottom: 4px; }
        .data-row:last-child { border-bottom: none; }
        .data-lbl { color: var(--c-text-dim); }
        .data-val { color: var(--c-text); font-weight: bold; text-align: right;}
        
        .tag { font-size: 0.7em; padding: 2px 4px; border-radius: 3px; margin-left: 5px; opacity: 0.9; display: inline-block; vertical-align: middle; }
        .tag-c { background: #064e3b; color: #6ee7b7; border: 1px solid #059669; }
        .tag-si { background: #312e81; color: #a5b4fc; border: 1px solid #4f46e5; }
        .tag-fe { background: #451a03; color: #fdba74; border: 1px solid #c2410c; }
        .tag-x { background: #4c1d95; color: #e9d5ff; border: 1px solid #8b5cf6; }
        .tag-bio { background: #831843; color: #f9a8d4; border: 1px solid #db2777; }
        .tag-none { background: #27272a; color: #a1a1aa; border: 1px solid #3f3f46; }

        .temp-range { font-size: 0.8em; opacity: 0.7; margin-left: 5px; }
        .t-min { color: #60a5fa; }
        .t-max { color: #f87171; }

        .tag-life { color: #10b981; text-shadow: 0 0 10px rgba(16,185,129,0.3); font-weight: bold; }
        .tag-dead { color: var(--c-text-dim); opacity: 0.5; }

        /* SLIDERS */
        .slider-group { margin-bottom: 12px; }
        .slider-header {
            display: flex; justify-content: space-between; font-size: 0.8rem;
            margin-bottom: 6px; color: var(--c-text-dim);
        }
        input[type="range"] {
            -webkit-appearance: none; width: 100%; height: 6px;
            background: #27272a; border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%;
            background: var(--c-text); cursor: pointer; border: 2px solid var(--c-bg);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .toggle-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 0; font-size: 0.9rem;
        }
        .switch { position: relative; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-switch {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #27272a; border-radius: 24px; transition: .3s;
        }
        .slider-switch:before {
            position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px;
            background-color: #a1a1aa; border-radius: 50%; transition: .3s;
        }
        input:checked + .slider-switch { background-color: var(--c-accent); }
        input:checked + .slider-switch:before { transform: translateX(20px); background-color: white; }

        .dl-group { margin-top: auto; padding: 24px; border-top: 1px solid var(--c-border); }
        .btn-dl {
            width: 100%; padding: 12px; background: transparent; border: 1px solid var(--c-border);
            color: var(--c-text); border-radius: 6px; cursor: pointer; font-family: var(--f-mono);
            font-size: 0.8rem; display: flex; align-items: center; justify-content: center; gap: 10px;
        }
        .btn-dl:hover { background: #27272a; }

        /* --- RESPONSIVE LAYOUT --- */
        @media (max-width: 800px) {
            body {
                grid-template-columns: 1fr;
                grid-template-rows: minmax(0, 1fr) auto;
                height: 100vh;
                overflow: hidden;
            }

            .deck {
                border-left: none;
                border-top: 1px solid var(--c-border);
                box-shadow: 0 -10px 40px rgba(0,0,0,0.5);
                max-height: 45vh;
                overflow-y: auto;
            }

            .dl-group { margin-top: 12px; padding: 12px; }
        }

    </style>
</head>
<body>

    <div class="stage" id="stage">
        <canvas id="webgl-canvas"></canvas>
    </div>

    <div id="texture-baker-container">
        <!-- Main Surface Baker -->
        <svg id="surface-baker" width="2048" height="1024" viewBox="0 0 2048 1024" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <filter id="geo-blur"><feGaussianBlur stdDeviation="25" /></filter>
                <filter id="liquid-blur"><feGaussianBlur stdDeviation="1" /></filter>
                <filter id="zone-warp">
                     <feTurbulence type="fractalNoise" baseFrequency="0.015" numOctaves="4" seed="123" result="turb"/>
                     <feDisplacementMap in="SourceGraphic" in2="turb" scale="60" xChannelSelector="R" yChannelSelector="G"/>
                     <feGaussianBlur stdDeviation="10" />
                </filter>
            </defs>
            <rect id="bake-bg" width="2048" height="1024" fill="#000" />
            <g id="bake-group-terrain"></g>
            <g id="bake-group-liquid"></g>
            <g id="bake-group-ice"></g>
            <g id="bake-group-bio"></g>
        </svg>

        <!-- Cloud Baker -->
        <svg id="cloud-baker" width="2048" height="1024" viewBox="0 0 2048 1024" xmlns="http://www.w3.org/2000/svg">
            <defs>
                 <filter id="cloud-fluff">
                    <feGaussianBlur stdDeviation="3" />
                    <feComponentTransfer>
                         <feFuncA type="linear" slope="2" intercept="0"/> 
                    </feComponentTransfer>
                </filter>
            </defs>
            <g id="bake-group-clouds" filter="url(#cloud-fluff)"></g>
        </svg>
    </div>

    <div class="deck">
        <div class="deck-header">
            <h1>SB PLANETGEN <span class="version">V12.5 T</span></h1>
            <div class="seed-row">
                <input type="text" id="seed-input" value="TERRA-PRIME">
                <button class="btn-icon" id="btn-rnd" title="Randomize">ðŸŽ²</button>
            </div>
        </div>

        <div class="controls">
            
            <div class="data-panel" id="data-panel">
                <div class="data-row"><span class="data-lbl">Temperature:</span> <span class="data-val" id="val-temp">--</span></div>
                <div class="data-row"><span class="data-lbl">Surface:</span> <span class="data-val" id="val-solid">--</span></div>
                <div class="data-row"><span class="data-lbl">Fluid:</span> <span class="data-val" id="val-liquid">--</span></div>
                <div class="data-row"><span class="data-lbl">Atmosphere:</span> <span class="data-val" id="val-atmos">--</span></div>
                <div class="data-row"><span class="data-lbl">Biology:</span> <span class="data-val tag-dead" id="val-life">NONE DETECTED</span></div>
            </div>

            <div>
                <div class="section-title">Manual Override</div>
                
                <div class="slider-group">
                    <div class="slider-header">
                        <span>Sea Level</span>
                        <span id="lbl-water">50%</span>
                    </div>
                    <input type="range" id="rng-water" min="0" max="100" value="50">
                </div>

                <div class="toggle-row">
                    <span>Auto Rotate</span>
                    <label class="switch">
                        <input type="checkbox" id="chk-auto-rotate" checked>
                        <span class="slider-switch"></span>
                    </label>
                </div>

                <div class="toggle-row">
                    <span>Show Clouds</span>
                    <label class="switch">
                        <input type="checkbox" id="chk-clouds" checked>
                        <span class="slider-switch"></span>
                    </label>
                </div>
            </div>

            <div>
                <div class="section-title">Lighting</div>
                <div class="slider-group">
                    <div class="slider-header">
                        <span>Sun Angle / Shadow</span>
                        <span id="lbl-shadow">50%</span>
                    </div>
                    <input type="range" id="rng-shadow" min="0" max="100" value="50">
                </div>
            </div>
            
            <button class="btn-action" id="btn-gen">Re-Generate</button>

        </div>

        <div class="dl-group">
            <button class="btn-dl" id="btn-download">
                <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg>
                Download Texture Map
            </button>
        </div>
    </div>

<script type="module">
import * as THREE from 'https://esm.sh/three';

/**
 * SB PLANETGEN V12.5 TURBO - HYBRID HIGH FIDELITY OPTIMIZED
 */

/* --- DATA CONSTANTS --- */
const LIQUIDS = [
    { name: "Water",           color: "#3b82f6", freeze: 0,    boil: 100,  tag: "H2O", cloud: "#ffffff", frozenColor: "#bfdbfe", type: "standard", gas: "Oxygen" },
    { name: "Salt Water",      color: "#1d4ed8", freeze: -2,   boil: 102,  tag: "H2O", cloud: "#f1f5f9", frozenColor: "#a5b4fc", type: "standard", gas: "Oxygen" },
    { name: "Mineral Water",   color: "#22d3ee", freeze: 0,    boil: 100,  tag: "H2O", cloud: "#ecfeff", frozenColor: "#cffafe", type: "standard", gas: "Oxygen" },
    { name: "Heavy Water",     color: "#60a5fa", freeze: 3.8,  boil: 101,  tag: "D2O", cloud: "#e0f2fe", frozenColor: "#93c5fd", type: "standard", gas: "Deuterium" },
    { name: "Brine",           color: "#0891b2", freeze: -21,  boil: 108,  tag: "H2O", cloud: "#f0f9ff", frozenColor: "#bae6fd", type: "standard", gas: "Chlorine" },
    { name: "Swamp Water",     color: "#3f6212", freeze: -1,   boil: 100,  tag: "Bio", cloud: "#d9f99d", frozenColor: "#65a30d", type: "organic",  gas: "Methane" },
    { name: "Mud Water",       color: "#78350f", freeze: 0,    boil: 100,  tag: "Si",  cloud: "#d6d3d1", frozenColor: "#57534e", type: "viscous",  gas: "Oxygen" },
    { name: "Oxygen",          color: "#93c5fd", freeze: -218, boil: -183, tag: "O",   cloud: "#e0f2fe", frozenColor: "#3b82f6", type: "volatile", gas: "Oxygen" },
    { name: "Nitrogen",        color: "#818cf8", freeze: -210, boil: -195, tag: "N",   cloud: "#f1f5f9", frozenColor: "#6366f1", type: "volatile", gas: "Nitrogen" },
    { name: "Hydrogen",        color: "#f0abfc", freeze: -259, boil: -252, tag: "H",   cloud: "#ffffff", frozenColor: "#e879f9", type: "volatile", gas: "Hydrogen" },
    { name: "Helium",          color: "#d8b4fe", freeze: -272, boil: -268, tag: "He",  cloud: "#ffffff", frozenColor: "#c084fc", type: "volatile", gas: "Helium" },
    { name: "Argon",           color: "#c084fc", freeze: -189, boil: -185, tag: "Ar",  cloud: "#e9d5ff", frozenColor: "#a855f7", type: "volatile", gas: "Argon" },
    { name: "Methane",         color: "#06b6d4", freeze: -182, boil: -161, tag: "C",   cloud: "#bae6fd", frozenColor: "#bae6fd", type: "volatile", gas: "Methane" },
    { name: "Propane",         color: "#67e8f9", freeze: -187, boil: -42,  tag: "C",   cloud: "#e0f2fe", frozenColor: "#22d3ee", type: "volatile", gas: "Propane" },
    { name: "Ethanol",         color: "#f1f5f9", freeze: -114, boil: 78,   tag: "C",   cloud: "#f8fafc", frozenColor: "#cbd5e1", type: "volatile", gas: "Carbon Monoxide" },
    { name: "Acetone",         color: "#e2e8f0", freeze: -95,  boil: 56,   tag: "C",   cloud: "#f8fafc", frozenColor: "#94a3b8", type: "volatile", gas: "Carbon Monoxide" },
    { name: "Gasoline",        color: "#facc15", freeze: -60,  boil: 200,  tag: "C",   cloud: "#fef08a", frozenColor: "#eab308", type: "standard", gas: "Carbon Dioxide" },
    { name: "Diesel",          color: "#d97706", freeze: -10,  boil: 300,  tag: "C",   cloud: "#78350f", frozenColor: "#92400e", type: "viscous",  gas: "Carbon Dioxide" },
    { name: "Kerosene",        color: "#fbbf24", freeze: -40,  boil: 250,  tag: "C",   cloud: "#fef3c7", frozenColor: "#f59e0b", type: "standard", gas: "Carbon Dioxide" },
    { name: "Napalm",          color: "#ea580c", freeze: -30,  boil: 200,  tag: "C",   cloud: "#9a3412", frozenColor: "#7c2d12", type: "viscous",  gas: "Carbon Dioxide" },
    { name: "Crude Oil",       color: "#0f172a", freeze: -57,  boil: 200,  tag: "C",   cloud: "#52525b", frozenColor: "#020617", type: "viscous",  gas: "Carbon Monoxide" },
    { name: "Tar",             color: "#171717", freeze: -10,  boil: 300,  tag: "C",   cloud: "#404040", frozenColor: "#0a0a0a", type: "viscous",  gas: "Carbon Dioxide" },
    { name: "Acid",            color: "#65a30d", freeze: 10,   boil: 337,  tag: "S",   cloud: "#d9f99d", frozenColor: "#365314", type: "acid",     gas: "Sulfur" },
    { name: "Vinegar",         color: "#fef08a", freeze: -2,   boil: 118,  tag: "C",   cloud: "#fef9c3", frozenColor: "#facc15", type: "acid",     gas: "Carbon Monoxide" },
    { name: "Ammonia",         color: "#2dd4bf", freeze: -77,  boil: -33,  tag: "N",   cloud: "#99f6e4", frozenColor: "#0d9488", type: "acid",     gas: "Nitrogen" },
    { name: "Chlorine",        color: "#84cc16", freeze: -101, boil: -34,  tag: "Cl",  cloud: "#bef264", frozenColor: "#4d7c0f", type: "acid",     gas: "Chlorine" },
    { name: "Bleach",          color: "#e0f2fe", freeze: -6,   boil: 101,  tag: "Cl",  cloud: "#f0f9ff", frozenColor: "#bae6fd", type: "standard", gas: "Chlorine" },
    { name: "Peroxide",        color: "#cbd5e1", freeze: -0.4, boil: 150,  tag: "O",   cloud: "#e0f2fe", frozenColor: "#64748b", type: "standard", gas: "Oxygen" },
    { name: "Cyanide",         color: "#cffafe", freeze: -13,  boil: 26,   tag: "C",   cloud: "#ecfeff", frozenColor: "#22d3ee", type: "acid",     gas: "Nitrogen" },
    { name: "Formaldehyde",    color: "#f0f9ff", freeze: -92,  boil: -19,  tag: "C",   cloud: "#e0f2fe", frozenColor: "#bae6fd", type: "acid",     gas: "Carbon Monoxide" },
    { name: "Bromine",         color: "#991b1b", freeze: -7,   boil: 58,   tag: "Br",  cloud: "#7f1d1d", frozenColor: "#450a0a", type: "standard", gas: "Bromine" },
    { name: "Mercury",         color: "#94a3b8", freeze: -39,  boil: 357,  tag: "Hg",  cloud: "#e2e8f0", frozenColor: "#475569", type: "metal",    gas: "Mercury" },
    { name: "Gallium",         color: "#cbd5e1", freeze: 29,   boil: 2400, tag: "Ga",  cloud: "#f1f5f9", frozenColor: "#64748b", type: "metal",    gas: "Gallium" },
    { name: "Blood",           color: "#991b1b", freeze: -2,   boil: 100,  tag: "Bio", cloud: "#fca5a5", frozenColor: "#7f1d1d", type: "organic",  gas: "Steam" },
    { name: "Plasma",          color: "#fde68a", freeze: -1,   boil: 100,  tag: "Bio", cloud: "#fef3c7", frozenColor: "#d97706", type: "organic",  gas: "Steam" },
    { name: "Venom",           color: "#a21caf", freeze: -5,   boil: 120,  tag: "Bio", cloud: "#e879f9", frozenColor: "#701a75", type: "acid",     gas: "Unknown" },
    { name: "Honey",           color: "#ea580c", freeze: -20,  boil: 120,  tag: "Bio", cloud: "#fde68a", frozenColor: "#9a3412", type: "viscous",  gas: "Carbon Dioxide" },
    { name: "Lava",            color: "#ef4444", freeze: 700,  boil: 3000, tag: "Si",  cloud: "#57534e", frozenColor: "#292524", type: "magma",    gas: "Silicate" },
    { name: "Magma",           color: "#c2410c", freeze: 800,  boil: 3200, tag: "Si",  cloud: "#44403c", frozenColor: "#1c1917", type: "magma",    gas: "Silicate" },
    { name: "Gold",            color: "#fbbf24", freeze: 1064, boil: 2700, tag: "Au",  cloud: "#fffbeb", frozenColor: "#b45309", type: "metal",    gas: "Vaporized Gold" },
    { name: "Iron",            color: "#f97316", freeze: 1538, boil: 2862, tag: "Fe",  cloud: "#ffedd5", frozenColor: "#c2410c", type: "metal",    gas: "Vaporized Iron" },
    { name: "Copper",          color: "#f87171", freeze: 1085, boil: 2562, tag: "Cu",  cloud: "#fecaca", frozenColor: "#991b1b", type: "metal",    gas: "Vaporized Copper" },
    { name: "Lead",            color: "#9ca3af", freeze: 327,  boil: 1749, tag: "Pb",  cloud: "#e5e7eb", frozenColor: "#4b5563", type: "metal",    gas: "Vaporized Lead" },
    { name: "Chocolate",       color: "#451a03", freeze: 25,   boil: 150,  tag: "Bio", cloud: "#d6d3d1", frozenColor: "#290e02", type: "viscous",  gas: "Carbon Dioxide" },
];

const SOLIDS = [
    { name: "Stone",           color: "#78716c", tag: "Si", roughness: 1.0, type: "rock", melt: 1200 },
    { name: "Basalt",          color: "#27272a", tag: "Si", roughness: 1.0, type: "rock", melt: 1100 },
    { name: "Granite",         color: "#a8a29e", tag: "Si", roughness: 1.3, type: "rock", melt: 1215 },
    { name: "Bedrock",         color: "#1c1917", tag: "Si", roughness: 2.0, type: "rock", melt: 4000 },
    { name: "Sandstone",       color: "#d97706", tag: "Si", roughness: 0.5, type: "rock", melt: 1300 },
    { name: "Limestone",       color: "#e7e5e4", tag: "C",  roughness: 0.8, type: "rock", melt: 900 },
    { name: "Slate",           color: "#475569", tag: "Si", roughness: 0.9, type: "rock", melt: 1200 },
    { name: "Marble",          color: "#cbd5e1", tag: "C",  roughness: 0.7, type: "rock", melt: 1200 },
    { name: "Pumice",          color: "#9ca3af", tag: "Si", roughness: 1.5, type: "rock", melt: 1000 },
    { name: "Obsidian",        color: "#2e1065", tag: "Si", roughness: 1.1, type: "glass",melt: 1000 },
    { name: "Flint",           color: "#374151", tag: "Si", roughness: 0.9, type: "rock", melt: 1700 },
    { name: "Coal",            color: "#0f172a", tag: "C",  roughness: 0.8, type: "rock", melt: 3500 },
    { name: "Chalk",           color: "#e5e7eb", tag: "C",  roughness: 0.6, type: "rock", melt: 825 },
    { name: "Shale",           color: "#334155", tag: "Si", roughness: 0.7, type: "rock", melt: 1100 },
    { name: "Dirt",            color: "#573c29", tag: "Si", roughness: 1.0, type: "dust", melt: 1100 },
    { name: "Mud",             color: "#451a03", tag: "Si", roughness: 0.9, type: "dust", melt: 1100 },
    { name: "Clay",            color: "#9a3412", tag: "Si", roughness: 0.6, type: "dust", melt: 1000 },
    { name: "Sand",            color: "#fde047", tag: "Si", roughness: 1.2, type: "dust", melt: 1700 },
    { name: "Red Sand",        color: "#ea580c", tag: "Si", roughness: 1.2, type: "dust", melt: 1600 },
    { name: "Black Sand",      color: "#18181b", tag: "Si", roughness: 1.1, type: "dust", melt: 1200 },
    { name: "Gravel",          color: "#9ca3af", tag: "Si", roughness: 1.5, type: "rock", melt: 1200 },
    { name: "Ash",             color: "#d6d3d1", tag: "C",  roughness: 1.4, type: "dust", melt: 1000 },
    { name: "Soot",            color: "#171717", tag: "C",  roughness: 1.2, type: "dust", melt: 3000 },
    { name: "Salt",            color: "#e5e7eb", tag: "Na", roughness: 0.8, type: "dust", melt: 801 },
    { name: "Iron Ore",        color: "#7f1d1d", tag: "Fe", roughness: 1.2, type: "metal", melt: 1538 },
    { name: "Magnetite",       color: "#1e293b", tag: "Fe", roughness: 1.1, type: "metal", melt: 1590 },
    { name: "Rust",            color: "#b45309", tag: "Fe", roughness: 1.5, type: "metal", melt: 1500 },
    { name: "Gold",            color: "#facc15", tag: "Au", roughness: 1.0, type: "metal", melt: 1064 },
    { name: "Pyrite",          color: "#ca8a04", tag: "Fe", roughness: 1.3, type: "rock",  melt: 1100 },
    { name: "Silver",          color: "#cbd5e1", tag: "Ag", roughness: 0.8, type: "metal", melt: 961 },
    { name: "Copper",          color: "#f97316", tag: "Cu", roughness: 0.9, type: "metal", melt: 1085 },
    { name: "Bronze",          color: "#cd7f32", tag: "Cu", roughness: 0.9, type: "metal", melt: 950 },
    { name: "Steel",           color: "#64748b", tag: "Fe", roughness: 0.8, type: "metal", melt: 1370 },
    { name: "Lead",            color: "#475569", tag: "Pb", roughness: 0.6, type: "metal", melt: 327 },
    { name: "Tin",             color: "#94a3b8", tag: "Sn", roughness: 0.7, type: "metal", melt: 231 },
    { name: "Aluminum",        color: "#d1d5db", tag: "Al", roughness: 0.6, type: "metal", melt: 660 },
    { name: "Titanium",        color: "#334155", tag: "Ti", roughness: 0.9, type: "metal", melt: 1668 },
    { name: "Tungsten",        color: "#1f2937", tag: "W",  roughness: 1.0, type: "metal", melt: 3422 },
    { name: "Cobalt",          color: "#1e3a8a", tag: "Co", roughness: 1.1, type: "metal", melt: 1495 },
    { name: "Uranium",         color: "#166534", tag: "U",  roughness: 1.0, type: "metal", melt: 1132 },
    { name: "Quartz",          color: "#e2e8f0", tag: "Si", roughness: 1.1, type: "glass", melt: 1670 },
    { name: "Diamond",         color: "#cffafe", tag: "C",  roughness: 1.5, type: "glass", melt: 4000 },
    { name: "Ruby",            color: "#dc2626", tag: "Al", roughness: 1.2, type: "glass", melt: 2050 },
    { name: "Sapphire",        color: "#2563eb", tag: "Al", roughness: 1.2, type: "glass", melt: 2040 },
    { name: "Emerald",         color: "#10b981", tag: "Si", roughness: 1.1, type: "glass", melt: 1200 },
    { name: "Amethyst",        color: "#a855f7", tag: "Si", roughness: 1.3, type: "glass", melt: 1650 },
    { name: "Topaz",           color: "#fb923c", tag: "Si", roughness: 1.1, type: "glass", melt: 1600 },
    { name: "Opal",            color: "#fda4af", tag: "Si", roughness: 0.9, type: "glass", melt: 1000 },
    { name: "Malachite",       color: "#064e3b", tag: "Cu", roughness: 1.0, type: "rock",  melt: 1100 },
    { name: "Sulfur",          color: "#fde047", tag: "S",  roughness: 0.8, type: "rock",  melt: 115 },
    { name: "Ice",             color: "#bae6fd", tag: "H2O",roughness: 0.7, type: "ice",   melt: 0 },
    { name: "Blue Ice",        color: "#60a5fa", tag: "H2O",roughness: 0.9, type: "ice",   melt: 0 },
    { name: "Permafrost",      color: "#9ca3af", tag: "Si", roughness: 1.1, type: "ice",   melt: 0 },
    { name: "Nitrogen Ice",    color: "#c7d2fe", tag: "N",  roughness: 0.5, type: "ice",   melt: -210 },
    { name: "Methane Ice",     color: "#38bdf8", tag: "C",  roughness: 0.5, type: "ice",   melt: -182 },
    { name: "Grass",           color: "#4ade80", tag: "Bio", roughness: 0.5, type: "organic", melt: 100 },
    { name: "Moss",            color: "#3f6212", tag: "Bio", roughness: 1.2, type: "organic", melt: 100 },
    { name: "Bone",            color: "#e5e5e5", tag: "Bio", roughness: 0.9, type: "organic", melt: 200 },
    { name: "Flesh",           color: "#fb7185", tag: "Bio", roughness: 0.5, type: "organic", melt: 100 },
    { name: "Chitin",          color: "#92400e", tag: "Bio", roughness: 0.7, type: "organic", melt: 260 },
    { name: "Mycelium",        color: "#ddd6fe", tag: "Bio", roughness: 1.2, type: "organic", melt: 150 },
    { name: "Coral",           color: "#f87171", tag: "Bio", roughness: 1.3, type: "organic", melt: 900 },
    { name: "Glass",           color: "#e0f2fe", tag: "Si", roughness: 0.1, type: "glass", melt: 1400 },
    { name: "Concrete",        color: "#d4d4d8", tag: "Si", roughness: 0.9, type: "rock",  melt: 1500 },
    { name: "Asphalt",         color: "#18181b", tag: "C",  roughness: 0.7, type: "rock",  melt: 175 },
    { name: "Plastic",         color: "#22d3ee", tag: "C",  roughness: 0.2, type: "organic", melt: 160 },
    { name: "Wax",             color: "#fef9c3", tag: "C",  roughness: 0.4, type: "organic", melt: 60 },
    { name: "Ceramic",         color: "#ffedd5", tag: "Si", roughness: 0.6, type: "rock",  melt: 2000 },
];

function hexToHSL(hex) {
    let r = parseInt(hex.substring(1,3), 16) / 255;
    let g = parseInt(hex.substring(3,5), 16) / 255;
    let b = parseInt(hex.substring(5,7), 16) / 255;
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max === min) { h = s = 0; } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h * 360, s: s * 100, l: l * 100 };
}

function hslToHex(h, s, l) {
    l /= 100;
    const a = s * Math.min(l, 1 - l) / 100;
    const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color).toString(16).padStart(2, '0');
    };
    return `#${f(0)}${f(8)}${f(4)}`;
}

function artColor(hex, lShift, sShift = 0, hShift = 0) {
    const hsl = hexToHSL(hex);
    let targetL = hsl.l + lShift;
    if (lShift > 0 && targetL > 85) {
        const excess = targetL - 85;
        targetL = 85 + (excess / (excess + 15)) * 12;
    }
    let newL = Math.max(5, Math.min(98, targetL));
    let newS = Math.max(0, Math.min(100, hsl.s + sShift));
    let newH = (hsl.h + hShift) % 360;
    if (newH < 0) newH += 360;
    return hslToHex(newH, newS, newL);
}

// Convert Hex to RGB Unit (0-1) for SVG Filters
function hexToRgbUnit(hex) {
    let r = parseInt(hex.substring(1,3), 16) / 255;
    let g = parseInt(hex.substring(3,5), 16) / 255;
    let b = parseInt(hex.substring(5,7), 16) / 255;
    return {r: r.toFixed(3), g: g.toFixed(3), b: b.toFixed(3)};
}

function createRNG(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash = hash & hash;
    }
    let seed = (hash >>> 0) || 1;
    return function() {
        seed |= 0;
        seed = seed + 0x6D2B79F5 | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

function getTagHtml(tag) {
    const colorMap = {
        'C': 'tag-c', 'H2O': 'tag-si', 'Bio': 'tag-bio',
        'Fe': 'tag-fe', 'Au': 'tag-fe', 'Cu': 'tag-fe', 'Ag': 'tag-fe', 'Pb': 'tag-fe', 'Sn': 'tag-fe', 'Al': 'tag-fe', 'Ti': 'tag-fe', 'W': 'tag-fe', 'Co': 'tag-fe',
        'Si': 'tag-fe', 'S': 'tag-fe', 'Na': 'tag-fe',
        'H': 'tag-si', 'He': 'tag-si', 'O': 'tag-si', 'N': 'tag-si', 'Ar': 'tag-si', 'Cl': 'tag-si', 'Br': 'tag-si', 'D2O': 'tag-si',
        'U': 'tag-x', 'Hg': 'tag-x', 'Ga': 'tag-x', 'X': 'tag-x'
    };
    return `<span class="tag ${colorMap[tag] || 'tag-none'}">${tag}</span>`;
}

/* --- STATE MANAGEMENT --- */
const state = {
    seed: 'INIT',
    data: null, 
    waterLevel: 50,
    shadow: 50,
    cloudsEnabled: true,
    autoRotate: true,
    // 3D Physics
    rotationSpeed: 0.1,
    isDragging: false,
    lastX: 0,
    velocity: 0.5
};

/* --- DOM REFERENCES --- */
const dom = {
    defs: document.querySelector('defs'),
    // Baker Groups
    bTerrain: document.getElementById('bake-group-terrain'),
    bLiquid: document.getElementById('bake-group-liquid'),
    bIce: document.getElementById('bake-group-ice'),
    bBio: document.getElementById('bake-group-bio'),
    bClouds: document.getElementById('bake-group-clouds'),
    bBg: document.getElementById('bake-bg'),
    // SVGs
    svgSurface: document.getElementById('surface-baker'),
    svgClouds: document.getElementById('cloud-baker'),
    // Inputs
    seedInput: document.getElementById('seed-input'),
    btnRnd: document.getElementById('btn-rnd'),
    btnGen: document.getElementById('btn-gen'),
    btnDownload: document.getElementById('btn-download'),
    rngWater: document.getElementById('rng-water'),
    rngShadow: document.getElementById('rng-shadow'),
    chkClouds: document.getElementById('chk-clouds'),
    chkAutoRotate: document.getElementById('chk-auto-rotate'),
    lblWater: document.getElementById('lbl-water'),
    lblShadow: document.getElementById('lbl-shadow'),
    // Readouts
    valTemp: document.getElementById('val-temp'),
    valLiquid: document.getElementById('val-liquid'),
    valSolid: document.getElementById('val-solid'),
    valAtmos: document.getElementById('val-atmos'),
    valLife: document.getElementById('val-life'),
};

/* --- THREE.JS SETUP --- */
const canvas = document.querySelector('#webgl-canvas');
const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
renderer.setSize(canvas.clientWidth, canvas.clientHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(40, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
camera.position.z = 3.8;

// Planet Group (Rotates)
const planetGroup = new THREE.Group();
scene.add(planetGroup);

// Sphere (Surface)
const geometry = new THREE.SphereGeometry(1, 128, 128); // Higher poly for smoothness
const material = new THREE.MeshStandardMaterial({ 
    roughness: 1.0, 
    metalness: 0.0,
});
const planetMesh = new THREE.Mesh(geometry, material);
planetGroup.add(planetMesh);

// Sphere (Clouds)
const cloudGeo = new THREE.SphereGeometry(1.025, 128, 128);
const cloudMat = new THREE.MeshStandardMaterial({ 
    transparent: true, opacity: 0.9, roughness: 1.0, side: THREE.DoubleSide 
});
const cloudMesh = new THREE.Mesh(cloudGeo, cloudMat);
planetGroup.add(cloudMesh);

// Atmosphere Glow (Shader)
const atmosGeo = new THREE.SphereGeometry(1.18, 64, 64);
const atmosMat = new THREE.ShaderMaterial({
    uniforms: {
        c: { type: "f", value: 0.3 },
        p: { type: "f", value: 4.5 },
        glowColor: { type: "c", value: new THREE.Color(0x3b82f6) },
        viewVector: { type: "v3", value: camera.position }
    },
    vertexShader: `
        uniform vec3 viewVector;
        varying float intensity;
        void main() {
            vec3 vNormal = normalize(normalMatrix * normal);
            vec3 vNormel = normalize(normalMatrix * viewVector);
            intensity = pow(0.65 - dot(vNormal, vNormel), 4.0);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform vec3 glowColor;
        varying float intensity;
        void main() {
            vec3 glow = glowColor * intensity;
            gl_FragColor = vec4(glow, intensity * 0.8);
        }
    `,
    side: THREE.BackSide,
    blending: THREE.AdditiveBlending,
    transparent: true
});
const atmosMesh = new THREE.Mesh(atmosGeo, atmosMat);
planetGroup.add(atmosMesh);

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.02); // Start dark
scene.add(ambientLight);
const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
sunLight.position.set(5, 2, 5);
scene.add(sunLight);

/* --- RESIZE HANDLER --- */
window.addEventListener('resize', () => {
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
});

/* --- GENERATION HELPERS --- */

// Re-creates the full 18-step palette for deep terrain detail
function generateDeepPalette(hex) {
    const s = hex;
    return [
        artColor(s, -60, 0, -27),
        artColor(s, -43, -4, -20),
        artColor(s, -30, -8, -14),
        s,
        artColor(s, -8, -6, -6),
        artColor(s, -4, -8, -2),
        artColor(s, 0, -7, 0),
        artColor(s, 4, -7, 3),
        artColor(s, 11, -8, 7),
        artColor(s, 13, -11, 11),
        artColor(s, 21, -12, 16),
        artColor(s, 21, -12, 16),
        artColor(s, 28, -14, 21),
        artColor(s, 28, -14, 21),
        artColor(s, 28, -14, 21),
        artColor(s, 36, -16, 26),
        artColor(s, 36, -16, 26),
        artColor(s, 42, -17, 32)
    ];
}

async function bakeSVGToTexture(svgElement) {
    const xml = new XMLSerializer().serializeToString(svgElement);
    const blob = new Blob([xml], {type: "image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            const tex = new THREE.Texture(img);
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            tex.needsUpdate = true;
            URL.revokeObjectURL(url);
            resolve(tex);
        };
        img.src = url;
    });
}

// RESTORED: "Proper" Cloud Generation Logic (Spines + Stacks)
function generateCloudsSVG(rng, data) {
    const R = 640; 
    
    // Helper: Create a curved path segment
    const generateCloudSpine = (yBase, width, xOffset) => {
        const points = [];
        const steps = 60;
        const startX = -width / 2 + xOffset;
        const stepSize = width / steps;
        let yDrift = 0;
        for (let i = 0; i <= steps; i++) {
            const xRel = startX + (i * stepSize);
            const xRatio = xRel / R;
            const sphereCurve = (xRatio * xRatio) * yBase * -0.8; 
            let y = yBase + sphereCurve;
            yDrift += (rng() - 0.5) * 1.0;
            yDrift *= 0.95;
            y += yDrift;
            points.push({ x: 1024 + xRel * 1.5, y: 512 + y }); 
        }
        return points;
    };

    // Helper: Expand spine into a bubbly shape
    const generateCloudShapeFromSpine = (spinePoints, options = {}) => {
        const { baseThickness=30, thicknessVariance=10, edgeNoise=10, taperPower=0.5 } = options;
        if (spinePoints.length < 3) return "";
        const topPoints = [], botPoints = [];
        let thickness = baseThickness;
        for (let i = 0; i < spinePoints.length; i++) {
            const p_curr = spinePoints[i];
            const p_next = spinePoints[Math.min(spinePoints.length-1, i+1)];
            const p_prev = spinePoints[Math.max(0, i-1)];
            const dx = p_next.x - p_prev.x, dy = p_next.y - p_prev.y;
            let nx = -dy, ny = dx;
            const len = Math.sqrt(nx*nx+ny*ny);
            if (len > 0) { nx /= len; ny /= len; }
            const progress = i / (spinePoints.length - 1);
            const taper = Math.sin(progress * Math.PI); 
            const thickMod = Math.pow(taper, taperPower);
            thickness += (rng() - 0.5) * (thicknessVariance / 5);
            thickness = Math.max(5, thickness); 
            const currentThick = thickness * thickMod;
            const jag = (rng() - 0.5) * edgeNoise * thickMod;
            topPoints.push({ x: p_curr.x + nx * (currentThick * 0.5 + jag), y: p_curr.y + ny * (currentThick * 0.5 + jag) });
            botPoints.push({ x: p_curr.x - nx * (currentThick * 0.5 + jag), y: p_curr.y - ny * (currentThick * 0.5 + jag) });
        }
        let d = `M ${topPoints[0].x.toFixed(1)} ${topPoints[0].y.toFixed(1)}`;
        for (let i = 1; i < topPoints.length; i++) d += ` L ${topPoints[i].x.toFixed(1)} ${topPoints[i].y.toFixed(1)}`;
        for (let i = botPoints.length - 1; i >= 0; i--) d += ` L ${botPoints[i].x.toFixed(1)} ${botPoints[i].y.toFixed(1)}`;
        d += " Z";
        return d;
    };

    // Helper: Create stack of cloud shapes (The "Proper" Design)
    const generateCloudSystem = (driverSpine, baseColor, yBase) => {
        const systemElements = [];
        const stackingDirection = yBase < 0 ? -1 : 1; 
        const createStack = (spine, layers, scale) => {
            const elements = [];
            for (let i = 0; i <= layers; i++) {
                const lengthRatio = 1.0 - (i * 0.08); 
                const subLength = Math.floor(spine.length * Math.max(0.4, lengthRatio));
                const slack = spine.length - subLength;
                const startIdx = Math.floor(rng() * (slack * 0.8) + (slack * 0.1));
                const baseSubSpine = spine.slice(startIdx, startIdx + subLength);
                const offsetDist = i * 14 * scale * stackingDirection; 
                const disjointX = (rng() - 0.5) * 20 * scale; 
                const offsetSubSpine = baseSubSpine.map((p, j, arr) => {
                    const p_next = arr[Math.min(arr.length-1, j+1)];
                    const p_prev = arr[Math.max(0, j-1)];
                    const dx = p_next.x - p_prev.x, dy = p_next.y - p_prev.y;
                    let nx = -dy, ny = dx;
                    const len = Math.sqrt(nx*nx+ny*ny);
                    if (len > 0) { nx /= len; ny /= len; }
                    return { x: p.x + (nx * offsetDist) + disjointX, y: p.y + (ny * offsetDist) };
                });
                const subPathData = generateCloudShapeFromSpine(offsetSubSpine, {
                    baseThickness: (35 - (i * 2)) * scale, edgeNoise: (12 + i) * scale, taperPower: 0.5
                });
                if (subPathData) {
                    const el = `<path d="${subPathData}" fill="${artColor(baseColor, 40 - (i * 10), -5)}" fill-opacity="0.6"/>`;
                    elements.push(el);
                }
            }
            return elements;
        };
        const mainLayers = Math.floor(rng() * 4) + 4; 
        systemElements.push(...createStack(driverSpine, mainLayers, 1.0));
        return systemElements;
    };

    const clusterCount = Math.floor(rng() * 3) + 3;
    const range = 1.85; 
    const zoneSize = range / clusterCount;
    let tileInner = "";
    
    // Generate horizontal bands
    for (let i = 0; i < clusterCount; i++) {
        const zoneTop = -(range/2) + (i * zoneSize);
        const latPos = zoneTop + (rng() * zoneSize * 0.8) + (zoneSize * 0.1);
        const yBase = latPos * R;
        const maxChord = Math.sqrt(Math.max(0, R*R - yBase*yBase)) * 2;
        const width = maxChord * (0.8 + rng() * 0.8);
        const maxOffset = (maxChord - width) / 2;
        const xOffset = (rng() * maxOffset * 2) - maxOffset;
        const dist = Math.abs(latPos);
        const col = artColor(data.cloudHex, dist * -15, dist * -5);
        
        const spine = generateCloudSpine(yBase, width, xOffset);
        const els = generateCloudSystem(spine, col, yBase);
        tileInner += els.join('');
    }
    // Duplicate for wrapping - OPTIMIZED: Using Groups
    let allPaths = `<g transform="translate(-2048,0)">${tileInner}</g>`;
    allPaths += `<g>${tileInner}</g>`;
    allPaths += `<g transform="translate(2048,0)">${tileInner}</g>`;
    return allPaths;
}

function generatePlanetData(rng) {
    let baseTemp = Math.floor(rng() * 450 - 150);
    if (rng() > 0.92) baseTemp += Math.floor(rng() * 4500);
    if (rng() < 0.12) baseTemp -= 150;
    const equatorOffset = Math.floor(rng() * 50 + 20);
    const poleOffset = Math.floor(rng() * 80 + 40);
    const maxT = baseTemp + equatorOffset;
    const minT = baseTemp - poleOffset;
    const validSolids = SOLIDS.filter(s => {
        if (s.type === 'ice' && baseTemp > s.melt) return false;
        return true;
    });
    let solid = validSolids.length > 0 ? validSolids[Math.floor(rng() * validSolids.length)] : { name: "Scorched Crust", color: "#1a0500", tag: "Si", roughness: 1.2, type: "rock", melt: 9999 };
    const solidMeltK = solid.melt + 273.15;
    let solidName = solid.name;
    const baseK = baseTemp + 273.15;
    if (baseK > solidMeltK * 3) {
        solidName = `Molten ${solid.name}`;
        solid = { ...solid, color: artColor(solid.color, 8, 5, 5) };
    }
    const potentialLiquids = LIQUIDS.filter(l => baseTemp > l.freeze);
    let liquid, oceanName, liquidState = "none", cloudColor, atmosContribution = 0;
    if (potentialLiquids.length > 0) {
        liquid = potentialLiquids[Math.floor(rng() * potentialLiquids.length)];
        oceanName = liquid.name;
        cloudColor = liquid.cloud;
        const liquidBoilK = liquid.boil + 273.15;
        if (baseK > liquidBoilK * 3) {
            liquidState = "sediment";
            oceanName = `${liquid.name} Sediment`;
            liquid = { ...liquid, color: artColor(liquid.color, -40, -30), tag: "Dry" };
            cloudColor = "#59544f"; 
            atmosContribution = 0.8;
        } else if (baseK > liquidBoilK) {
            liquidState = "boiling";
            oceanName = `Boiling ${liquid.name}`;
            atmosContribution = 0.4;
        } else {
            liquidState = "liquid";
            atmosContribution = 0.1; 
        }
    } else {
        liquidState = "none";
        oceanName = "None";
        liquid = { name: "None", tag: "-", frozenColor: "#a1a1aa", cloud: "#a1a1aa" };
        cloudColor = "#a1a1aa";
    }
    let atmosName = "None", atmosDensity = 0;
    if (rng() > 0.2) { 
        atmosDensity = rng() * 0.3; 
        atmosDensity += atmosContribution;
        atmosDensity = Math.max(0, Math.min(1, atmosDensity)); 
        if (liquidState === "sediment") {
            atmosDensity = 0.9 + (rng() * 0.1);
            atmosName = `Dense Vaporized ${liquid.name}`;
        } else if (atmosDensity < 0.05) {
            atmosName = "Trace Gases";
        } else {
            const desc = atmosDensity > 0.7 ? "Dense" : atmosDensity > 0.35 ? "Moderate" : "Thin";
            const gas = (liquid.gas && liquidState !== "none") ? liquid.gas : "Inert Mix";
            atmosName = `${desc} ${gas}`;
        }
    } else {
        atmosName = "Vacuum";
    }
    let hasLife = false, lifeType = "None", bioColor = null, bioMinT = 0, bioMaxT = 0;
    if (liquidState === "liquid") {
        if (liquid.tag === "H2O" && baseTemp > -20 && baseTemp < 80) {
            hasLife = true; lifeType = "Carbon-Based"; bioColor = "#10b981"; bioMinT = -20; bioMaxT = 80;
        } else if (solid.tag === "Si" && baseTemp > 400 && baseTemp < 1200) {
            hasLife = true; lifeType = "Silicon-Based"; bioColor = "#9333ea"; bioMinT = 400; bioMaxT = 1200;
        } else if (liquid.tag === "C" && baseTemp < -100) {
            hasLife = true; lifeType = "Hydrocarbon-Based"; bioColor = "#f43f5e"; bioMinT = -200; bioMaxT = -100;
        } else if (solid.tag === "U" || solid.tag === "X") {
            hasLife = true; lifeType = "Radiotrophic"; bioColor = "#bef264"; bioMinT = baseTemp - 50; bioMaxT = baseTemp + 50;
        }
    }
    const getLatForTemp = (t) => (maxT === minT) ? 0.5 : (maxT - t) / (maxT - minT);
    let latBoil = getLatForTemp(liquid.boil || 9999);
    let latFreeze = getLatForTemp(liquid.freeze || 9998);
    if (liquidState === "sediment") latBoil = -2.0;
    let suggestedWater = (liquidState === "none" || liquidState === "sediment") ? Math.floor(rng() * 15) : Math.floor(rng() * 40 + 30);
    if (hasLife) suggestedWater = Math.floor(rng() * 20 + 45);
    return {
        baseTemp, maxT, minT, solid, liquid, latBoil, latFreeze, oceanName, solidName, atmosName, atmosDensity,
        cloudHex: cloudColor, hasLife, lifeType, bioColor, bioMinT, bioMaxT, rings: rng() < 0.15,
        baseFreq: 0.006 - ((solid.roughness * 0.5) * 0.0045), suggestedWater, roughness: solid.roughness * (0.5 + rng())
    };
}

async function fullRebuild() {
    dom.btnGen.disabled = true;
    dom.btnGen.innerText = "Simulating...";
    
    // Clear SVGs
    dom.bTerrain.innerHTML = '';
    dom.bLiquid.innerHTML = '';
    dom.bIce.innerHTML = '';
    dom.bBio.innerHTML = '';
    dom.bClouds.innerHTML = '';
    dom.defs.querySelectorAll('.dynamic-def').forEach(el => el.remove());

    const rng = createRNG(state.seed);
    state.data = generatePlanetData(rng);
    const data = state.data;
    const palette = generateDeepPalette(data.solid.color); // 18 colors!

    // Update Text UI with Ranges and Tags
    dom.valTemp.innerHTML = `${data.baseTemp}Â°C <span class="temp-range">(<span class="t-min">${data.minT}Â°</span> / <span class="t-max">${data.maxT}Â°</span>)</span>`;
    dom.valLiquid.innerHTML = data.oceanName + getTagHtml(data.liquid.tag);
    dom.valSolid.innerHTML = data.solidName + getTagHtml(data.solid.tag);
    dom.valAtmos.innerText = data.atmosName;
    dom.valLife.innerHTML = data.hasLife ? data.lifeType : "STERILE";
    dom.valLife.className = data.hasLife ? "data-val tag-life" : "data-val tag-dead";

    // Update Atmosphere Glow Color
    atmosMat.uniforms.glowColor.value.set(data.cloudHex);
    atmosMat.uniforms.c.value = 0.2 + (data.atmosDensity * 0.3);
    atmosMesh.visible = data.atmosDensity > 0.05;

    // 1. GENERATE NOISE PATTERN (TILED 1024x1024)
    // We generate one noise map and reuse it for EVERYTHING.
    const noiseID = `noise-${state.seed}`;
    const noiseFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    noiseFilter.setAttribute("id", noiseID);
    noiseFilter.setAttribute("x", "0%"); noiseFilter.setAttribute("y", "0%"); 
    noiseFilter.setAttribute("width", "100%"); noiseFilter.setAttribute("height", "100%");
    noiseFilter.classList.add('dynamic-def');
    
    // Using feColorMatrix to ensure grayscale contrast is standardized
    noiseFilter.innerHTML = `
        <feTurbulence type="fractalNoise" baseFrequency="${data.baseFreq}" numOctaves="6" seed="${Math.floor(rng()*100)}" stitchTiles="stitch" result="turb"/>
        <feColorMatrix type="saturate" values="0" in="turb" result="gray"/>
        <feComponentTransfer in="gray" result="contrasted">
            <feFuncR type="linear" slope="3" intercept="-1"/>
            <feFuncG type="linear" slope="3" intercept="-1"/>
            <feFuncB type="linear" slope="3" intercept="-1"/>
        </feComponentTransfer>
    `;
    dom.defs.appendChild(noiseFilter);

    // Create Pattern Def used by all layers
    const noisePatternId = `pat-noise-${state.seed}`;
    const pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
    pattern.setAttribute("id", noisePatternId);
    pattern.setAttribute("patternUnits", "userSpaceOnUse");
    pattern.setAttribute("width", "1024"); pattern.setAttribute("height", "1024");
    pattern.classList.add('dynamic-def');
    pattern.innerHTML = `<rect width="1024" height="1024" filter="url(#${noiseID})"/>`;
    dom.defs.appendChild(pattern);

    // 2. TERRAIN LAYERS - OPTIMIZED: COLOR MAPPING
    // Instead of 18 masks (slow!), we use one feComponentTransfer to map luminance to palette colors.
    
    // Prepare table values for R, G, B
    let rVals = [], gVals = [], bVals = [];
    palette.forEach(hex => {
        const rgb = hexToRgbUnit(hex);
        rVals.push(rgb.r); gVals.push(rgb.g); bVals.push(rgb.b);
    });
    
    const mapFilterId = `terrain-map-${state.seed}`;
    const mapFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    mapFilter.setAttribute("id", mapFilterId);
    mapFilter.classList.add('dynamic-def');
    
    // 'discrete' type creates hard edges between colors, mimicking the "threshold" look exactly without the cost.
    mapFilter.innerHTML = `
        <feComponentTransfer>
            <feFuncR type="discrete" tableValues="${rVals.join(' ')}"/>
            <feFuncG type="discrete" tableValues="${gVals.join(' ')}"/>
            <feFuncB type="discrete" tableValues="${bVals.join(' ')}"/>
        </feComponentTransfer>
    `;
    dom.defs.appendChild(mapFilter);

    // One single rect for the terrain
    const terrainRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    terrainRect.setAttribute("width", "2048"); terrainRect.setAttribute("height", "1024");
    terrainRect.setAttribute("fill", `url(#${noisePatternId})`);
    terrainRect.setAttribute("filter", `url(#${mapFilterId})`);
    dom.bTerrain.appendChild(terrainRect);


    // 3. LIQUID / ICE MASKS
    const lMaskId = `filter-mask-liq-${state.seed}`;
    const lFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    lFilter.setAttribute("id", lMaskId);
    lFilter.classList.add('dynamic-def');
    // Initial slope/intercept will be set by softUpdate immediately after
    lFilter.innerHTML = `<feComponentTransfer><feFuncR type="linear" slope="1" intercept="0" /><feFuncG type="linear" slope="1" intercept="0" /><feFuncB type="linear" slope="1" intercept="0" /></feComponentTransfer>`;
    dom.defs.appendChild(lFilter);

    const liqMask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
    liqMask.setAttribute("id", `mask-liq-${state.seed}`);
    liqMask.classList.add('dynamic-def');
    const lmRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    lmRect.setAttribute("width","2048"); lmRect.setAttribute("height","1024");
    lmRect.setAttribute("fill", `url(#${noisePatternId})`);
    lmRect.setAttribute("filter", `url(#${lMaskId})`);
    liqMask.appendChild(lmRect);
    dom.defs.appendChild(liqMask);

    // Liquid Rect
    const lRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    lRect.setAttribute("width","2048"); lRect.setAttribute("height","1024");
    lRect.setAttribute("fill", data.liquid.color);
    lRect.setAttribute("mask", `url(#mask-liq-${state.seed})`);
    if(data.liquid.type !== "magma") lRect.setAttribute("filter", "url(#liquid-blur)");
    dom.bLiquid.appendChild(lRect);

    // Ice Zone Logic
    const zoneGradId = `grad-zones-${state.seed}`;
    const zoneGrad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    zoneGrad.setAttribute("id", zoneGradId);
    zoneGrad.setAttribute("x1", "0"); zoneGrad.setAttribute("y1", "0"); zoneGrad.setAttribute("x2", "0"); zoneGrad.setAttribute("y2", "1"); 
    zoneGrad.classList.add('dynamic-def');
    const fTop = (0.5 - data.latFreeze*0.5)*100;
    const fBot = (0.5 + data.latFreeze*0.5)*100;
    zoneGrad.innerHTML = `<stop offset="0%" stop-color="#fff"/><stop offset="${fTop}%" stop-color="#fff"/><stop offset="${fTop}%" stop-color="#000"/><stop offset="${fBot}%" stop-color="#000"/><stop offset="${fBot}%" stop-color="#fff"/><stop offset="100%" stop-color="#fff"/>`;
    dom.defs.appendChild(zoneGrad);

    // Ice Mask
    const iceZoneMaskId = `mask-ice-zone-${state.seed}`;
    const izMask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
    izMask.setAttribute("id", iceZoneMaskId);
    izMask.classList.add('dynamic-def');
    izMask.innerHTML = `<rect width="2048" height="1024" fill="url(#${zoneGradId})" filter="url(#zone-warp)"/>`;
    dom.defs.appendChild(izMask);
    
    const iGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    iGroup.setAttribute("mask", `url(#${iceZoneMaskId})`);
    const iRect = lRect.cloneNode(); 
    iRect.setAttribute("fill", data.liquid.frozenColor);
    iRect.setAttribute("filter", ""); 
    iGroup.appendChild(iRect);
    dom.bIce.appendChild(iGroup);

    // 4. CLOUDS (Procedural Bands)
    if (state.cloudsEnabled && data.atmosDensity > 0.05) {
        const cloudSVG = generateCloudsSVG(rng, data);
        dom.bClouds.innerHTML = cloudSVG;
    }

    // UPDATE THREE.JS TEXTURES
    softUpdate(true); // Sets thresholds based on water level
    
    // Bake Surface
    const surfaceTex = await bakeSVGToTexture(dom.svgSurface);
    material.map = surfaceTex;
    material.needsUpdate = true;
    
    // Bake Clouds
    if (state.cloudsEnabled) {
        const cloudTex = await bakeSVGToTexture(dom.svgClouds);
        cloudMesh.material.map = cloudTex;
        cloudMesh.visible = true;
    } else {
        cloudMesh.visible = false;
    }
    cloudMesh.material.needsUpdate = true;

    // Reset Tilt
    planetMesh.rotation.z = 0;
    cloudMesh.rotation.z = 0;

    dom.btnGen.disabled = false;
    dom.btnGen.innerText = "Re-Generate";
}

function softUpdate(isGenerating = false) {
    const waterFactor = state.waterLevel / 100;
    
    // Update SVG Thresholds
    const updateFilter = (id, slope, intercept) => {
        const f = document.getElementById(id);
        if(!f) return;
        const funcs = f.querySelectorAll('feFuncR, feFuncG, feFuncB');
        funcs.forEach(el => {
            el.setAttribute('slope', slope);
            el.setAttribute('intercept', intercept);
        });
    };

    // Update Liquid Mask
    const lMaskId = `filter-mask-liq-${state.seed}`;
    // Liquid noise is 0..1. High water factor means we accept more noise values.
    const slope = -50;
    const intercept = (waterFactor * 50) + 0.5; 
    updateFilter(lMaskId, slope, intercept);

    // Update Lighting from Shadow Slider
    const sunIntensity = (100 - state.shadow) / 50 * 2.0;
    const ambientIntensity = (state.shadow) / 100 * 0.4; // More ambient in "shadowy" settings
    sunLight.intensity = Math.max(0.1, sunIntensity);
    ambientLight.intensity = Math.max(0.02, ambientIntensity);
    
    // Clouds Visibility
    cloudMesh.visible = state.cloudsEnabled;

    if (!isGenerating) {
        // If simply sliding slider, re-bake surface
        bakeSVGToTexture(dom.svgSurface).then(tex => {
            if(material.map) material.map.dispose();
            material.map = tex;
            material.needsUpdate = true;
        });
    }
}

/* --- INTERACTION (DRAG & SPIN) --- */
function initInteraction() {
    const stage = document.getElementById('stage');
    
    const handleStart = (x) => {
        state.isDragging = true;
        state.lastX = x;
        state.velocity = 0;
        state.autoRotate = false;
        dom.chkAutoRotate.checked = false;
    };

    const handleMove = (x) => {
        if (!state.isDragging) return;
        const delta = x - state.lastX;
        state.lastX = x;
        state.velocity = delta * 0.005; // Sensitivity
        planetGroup.rotation.y += state.velocity;
    };

    const handleEnd = () => {
        state.isDragging = false;
    };

    // Mouse
    stage.addEventListener('mousedown', e => handleStart(e.clientX));
    window.addEventListener('mousemove', e => handleMove(e.clientX));
    window.addEventListener('mouseup', handleEnd);

    // Touch
    stage.addEventListener('touchstart', e => handleStart(e.touches[0].clientX));
    window.addEventListener('touchmove', e => handleMove(e.touches[0].clientX));
    window.addEventListener('touchend', handleEnd);
}

/* --- ANIMATION LOOP --- */
function animate() {
    requestAnimationFrame(animate);

    if (!state.isDragging) {
        if (state.autoRotate) {
            state.velocity = 0.001; // Slower, majestic rotation
        } else {
            state.velocity *= 0.95;
            if (Math.abs(state.velocity) < 0.0001) state.velocity = 0;
        }
        planetGroup.rotation.y += state.velocity;
        
        // Cloud Parallax (Local Rotation)
        cloudMesh.rotation.y += 0.0003; 
    }

    renderer.render(scene, camera);
}

/* --- INITIALIZATION --- */
window.onload = () => {
    // Handlers
    const triggerRebuild = () => {
        state.seed = dom.seedInput.value.toUpperCase();
        state.waterLevel = parseInt(dom.rngWater.value);
        state.shadow = parseInt(dom.rngShadow.value);
        state.cloudsEnabled = dom.chkClouds.checked;
        state.autoRotate = dom.chkAutoRotate.checked;
        fullRebuild();
    }

    dom.btnRnd.addEventListener('click', () => {
        const pfx = ["TERRA", "AQUA", "MAGMA", "CRYO", "XENO", "LUNA", "SOL"];
        dom.seedInput.value = `${pfx[Math.floor(Math.random()*pfx.length)]}-${Math.floor(Math.random()*9999)}`;
        const tmpRng = createRNG(dom.seedInput.value);
        const tmpData = generatePlanetData(tmpRng);
        dom.rngWater.value = tmpData.suggestedWater;
        dom.lblWater.innerText = tmpData.suggestedWater + '%';
        triggerRebuild();
    });

    dom.btnGen.addEventListener('click', triggerRebuild);
    dom.seedInput.addEventListener('change', triggerRebuild);
    dom.rngWater.addEventListener('change', () => { 
        state.waterLevel = parseInt(dom.rngWater.value);
        dom.lblWater.innerText = state.waterLevel + '%';
        softUpdate();
    });
    dom.rngWater.addEventListener('input', () => dom.lblWater.innerText = dom.rngWater.value + '%');

    dom.rngShadow.addEventListener('input', () => {
        state.shadow = parseInt(dom.rngShadow.value);
        dom.lblShadow.innerText = state.shadow + '%';
        softUpdate();
    });

    dom.chkClouds.addEventListener('change', () => {
        state.cloudsEnabled = dom.chkClouds.checked;
        softUpdate();
    });
    
    dom.chkAutoRotate.addEventListener('change', () => {
        state.autoRotate = dom.chkAutoRotate.checked;
    });

    dom.btnDownload.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `PLANETMAP_${state.seed}.png`;
        link.href = material.map.image.src;
        link.click();
    });

    // Init
    initInteraction();
    const initRng = createRNG(dom.seedInput.value);
    const initData = generatePlanetData(initRng);
    dom.rngWater.value = initData.suggestedWater;
    dom.lblWater.innerText = initData.suggestedWater + '%';
    triggerRebuild();
    animate();
};
</script>
</body>
</html>
